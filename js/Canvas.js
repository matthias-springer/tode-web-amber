smalltalk.addPackage('Canvas');
smalltalk.addClass('HTMLCanvas', smalltalk.Object, ['root'], 'Canvas');
smalltalk.addMethod(
smalltalk.method({
selector: "a",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("a");
return $1;
}, function($ctx1) {$ctx1.fill(self,"a",{},smalltalk.HTMLCanvas)})},
args: [],
source: "a\x0a\x09^self tag: 'a'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "abbr",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("abbr");
return $1;
}, function($ctx1) {$ctx1.fill(self,"abbr",{},smalltalk.HTMLCanvas)})},
args: [],
source: "abbr\x0a\x09^self tag: 'abbr'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "address",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("address");
return $1;
}, function($ctx1) {$ctx1.fill(self,"address",{},smalltalk.HTMLCanvas)})},
args: [],
source: "address\x0a\x09^self tag: 'address'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "area",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("area");
return $1;
}, function($ctx1) {$ctx1.fill(self,"area",{},smalltalk.HTMLCanvas)})},
args: [],
source: "area\x0a\x09^self tag: 'area'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "article",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("article");
return $1;
}, function($ctx1) {$ctx1.fill(self,"article",{},smalltalk.HTMLCanvas)})},
args: [],
source: "article\x0a\x09^self tag: 'article'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "aside",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("aside");
return $1;
}, function($ctx1) {$ctx1.fill(self,"aside",{},smalltalk.HTMLCanvas)})},
args: [],
source: "aside\x0a\x09^self tag: 'aside'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "audio",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("audio");
return $1;
}, function($ctx1) {$ctx1.fill(self,"audio",{},smalltalk.HTMLCanvas)})},
args: [],
source: "audio\x0a\x09^self tag: 'audio'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "base",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("base");
return $1;
}, function($ctx1) {$ctx1.fill(self,"base",{},smalltalk.HTMLCanvas)})},
args: [],
source: "base\x0a\x09^self tag: 'base'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "blockquote",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("blockquote");
return $1;
}, function($ctx1) {$ctx1.fill(self,"blockquote",{},smalltalk.HTMLCanvas)})},
args: [],
source: "blockquote\x0a\x09^self tag: 'blockquote'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "body",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("body");
return $1;
}, function($ctx1) {$ctx1.fill(self,"body",{},smalltalk.HTMLCanvas)})},
args: [],
source: "body\x0a\x09^self tag: 'body'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "br",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("br");
return $1;
}, function($ctx1) {$ctx1.fill(self,"br",{},smalltalk.HTMLCanvas)})},
args: [],
source: "br\x0a\x09^self tag: 'br'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "button",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("button");
return $1;
}, function($ctx1) {$ctx1.fill(self,"button",{},smalltalk.HTMLCanvas)})},
args: [],
source: "button\x0a\x09^self tag: 'button'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "canvas",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("canvas");
return $1;
}, function($ctx1) {$ctx1.fill(self,"canvas",{},smalltalk.HTMLCanvas)})},
args: [],
source: "canvas\x0a\x09^self tag: 'canvas'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "caption",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("caption");
return $1;
}, function($ctx1) {$ctx1.fill(self,"caption",{},smalltalk.HTMLCanvas)})},
args: [],
source: "caption\x0a\x09^self tag: 'caption'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "cite",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("cite");
return $1;
}, function($ctx1) {$ctx1.fill(self,"cite",{},smalltalk.HTMLCanvas)})},
args: [],
source: "cite\x0a\x09^self tag: 'cite'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "code",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("code");
return $1;
}, function($ctx1) {$ctx1.fill(self,"code",{},smalltalk.HTMLCanvas)})},
args: [],
source: "code\x0a\x09^self tag: 'code'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "col",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("col");
return $1;
}, function($ctx1) {$ctx1.fill(self,"col",{},smalltalk.HTMLCanvas)})},
args: [],
source: "col\x0a\x09^self tag: 'col'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "colgroup",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("colgroup");
return $1;
}, function($ctx1) {$ctx1.fill(self,"colgroup",{},smalltalk.HTMLCanvas)})},
args: [],
source: "colgroup\x0a\x09^self tag: 'colgroup'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "command",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("command");
return $1;
}, function($ctx1) {$ctx1.fill(self,"command",{},smalltalk.HTMLCanvas)})},
args: [],
source: "command\x0a\x09^self tag: 'command'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "datalist",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("datalist");
return $1;
}, function($ctx1) {$ctx1.fill(self,"datalist",{},smalltalk.HTMLCanvas)})},
args: [],
source: "datalist\x0a\x09^self tag: 'datalist'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "dd",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("dd");
return $1;
}, function($ctx1) {$ctx1.fill(self,"dd",{},smalltalk.HTMLCanvas)})},
args: [],
source: "dd\x0a\x09^self tag: 'dd'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "del",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("del");
return $1;
}, function($ctx1) {$ctx1.fill(self,"del",{},smalltalk.HTMLCanvas)})},
args: [],
source: "del\x0a\x09^self tag: 'del'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "details",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("details");
return $1;
}, function($ctx1) {$ctx1.fill(self,"details",{},smalltalk.HTMLCanvas)})},
args: [],
source: "details\x0a\x09^self tag: 'details'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "div",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("div");
return $1;
}, function($ctx1) {$ctx1.fill(self,"div",{},smalltalk.HTMLCanvas)})},
args: [],
source: "div\x0a\x09^self tag: 'div'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "div:",
category: 'tags',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._div())._with_(aBlock);
return $1;
}, function($ctx1) {$ctx1.fill(self,"div:",{aBlock:aBlock},smalltalk.HTMLCanvas)})},
args: ["aBlock"],
source: "div: aBlock\x0a\x09^self div with: aBlock",
messageSends: ["with:", "div"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "dl",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("dl");
return $1;
}, function($ctx1) {$ctx1.fill(self,"dl",{},smalltalk.HTMLCanvas)})},
args: [],
source: "dl\x0a\x09^self tag: 'dl'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "dt",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("dt");
return $1;
}, function($ctx1) {$ctx1.fill(self,"dt",{},smalltalk.HTMLCanvas)})},
args: [],
source: "dt\x0a\x09^self tag: 'dt'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "em",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("em");
return $1;
}, function($ctx1) {$ctx1.fill(self,"em",{},smalltalk.HTMLCanvas)})},
args: [],
source: "em\x0a\x09^self tag: 'em'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "embed",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("embed");
return $1;
}, function($ctx1) {$ctx1.fill(self,"embed",{},smalltalk.HTMLCanvas)})},
args: [],
source: "embed\x0a\x09^self tag: 'embed'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "entity:",
category: 'adding',
fn: function (aString){
var self=this;
var result;
return smalltalk.withContext(function($ctx1) { 
var $1;
result=_st(_st(_st("<span />")._asJQuery())._html_(_st(_st("&").__comma(aString)).__comma(";")))._text();
$1=_st(_st(result)._size()).__eq((1));
if(! smalltalk.assert($1)){
_st(self)._error_(_st("Not an HTML entity: ").__comma(aString));
};
_st(self)._with_(result);
return self}, function($ctx1) {$ctx1.fill(self,"entity:",{aString:aString,result:result},smalltalk.HTMLCanvas)})},
args: ["aString"],
source: "entity: aString\x0a\x09\x22Adds a character representing html entity, eg.\x0a\x09html entity: 'copy'\x0a\x09adds a copyright sign.\x0a\x09If a name does not represent valid HTML entity, error is raised.\x22\x0a\x09| result |\x0a\x09result := ('<span />' asJQuery html: '&', aString, ';') text.\x0a\x09result size = 1 ifFalse: [ self error: 'Not an HTML entity: ', aString ].\x0a\x09self with: result",
messageSends: ["text", "html:", ",", "asJQuery", "ifFalse:", "error:", "=", "size", "with:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "fieldset",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("fieldset");
return $1;
}, function($ctx1) {$ctx1.fill(self,"fieldset",{},smalltalk.HTMLCanvas)})},
args: [],
source: "fieldset\x0a\x09^self tag: 'fieldset'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "figcaption",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("figcaption");
return $1;
}, function($ctx1) {$ctx1.fill(self,"figcaption",{},smalltalk.HTMLCanvas)})},
args: [],
source: "figcaption\x0a\x09^self tag: 'figcaption'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "figure",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("figure");
return $1;
}, function($ctx1) {$ctx1.fill(self,"figure",{},smalltalk.HTMLCanvas)})},
args: [],
source: "figure\x0a\x09^self tag: 'figure'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "footer",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("footer");
return $1;
}, function($ctx1) {$ctx1.fill(self,"footer",{},smalltalk.HTMLCanvas)})},
args: [],
source: "footer\x0a\x09^self tag: 'footer'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "form",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("form");
return $1;
}, function($ctx1) {$ctx1.fill(self,"form",{},smalltalk.HTMLCanvas)})},
args: [],
source: "form\x0a\x09^self tag: 'form'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "h1",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("h1");
return $1;
}, function($ctx1) {$ctx1.fill(self,"h1",{},smalltalk.HTMLCanvas)})},
args: [],
source: "h1\x0a\x09^self tag: 'h1'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "h1:",
category: 'tags',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._h1())._with_(anObject);
return $1;
}, function($ctx1) {$ctx1.fill(self,"h1:",{anObject:anObject},smalltalk.HTMLCanvas)})},
args: ["anObject"],
source: "h1: anObject\x0a\x09^self h1 with: anObject",
messageSends: ["with:", "h1"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "h2",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("h2");
return $1;
}, function($ctx1) {$ctx1.fill(self,"h2",{},smalltalk.HTMLCanvas)})},
args: [],
source: "h2\x0a\x09^self tag: 'h2'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "h2:",
category: 'tags',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._h2())._with_(anObject);
return $1;
}, function($ctx1) {$ctx1.fill(self,"h2:",{anObject:anObject},smalltalk.HTMLCanvas)})},
args: ["anObject"],
source: "h2: anObject\x0a\x09^ self h2 with: anObject",
messageSends: ["with:", "h2"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "h3",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("h3");
return $1;
}, function($ctx1) {$ctx1.fill(self,"h3",{},smalltalk.HTMLCanvas)})},
args: [],
source: "h3\x0a\x09^self tag: 'h3'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "h3:",
category: 'tags',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._h3())._with_(anObject);
return $1;
}, function($ctx1) {$ctx1.fill(self,"h3:",{anObject:anObject},smalltalk.HTMLCanvas)})},
args: ["anObject"],
source: "h3: anObject\x0a\x09^self h3 with: anObject",
messageSends: ["with:", "h3"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "h4",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("h4");
return $1;
}, function($ctx1) {$ctx1.fill(self,"h4",{},smalltalk.HTMLCanvas)})},
args: [],
source: "h4\x0a\x09^self tag: 'h4'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "h4:",
category: 'tags',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._h4())._with_(anObject);
return $1;
}, function($ctx1) {$ctx1.fill(self,"h4:",{anObject:anObject},smalltalk.HTMLCanvas)})},
args: ["anObject"],
source: "h4: anObject\x0a\x09^self h4 with: anObject",
messageSends: ["with:", "h4"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "h5",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("h5");
return $1;
}, function($ctx1) {$ctx1.fill(self,"h5",{},smalltalk.HTMLCanvas)})},
args: [],
source: "h5\x0a\x09^self tag: 'h5'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "h5:",
category: 'tags',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._h5())._with_(anObject);
return $1;
}, function($ctx1) {$ctx1.fill(self,"h5:",{anObject:anObject},smalltalk.HTMLCanvas)})},
args: ["anObject"],
source: "h5: anObject\x0a\x09^self h5 with: anObject",
messageSends: ["with:", "h5"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "h6",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("h6");
return $1;
}, function($ctx1) {$ctx1.fill(self,"h6",{},smalltalk.HTMLCanvas)})},
args: [],
source: "h6\x0a\x09^self tag: 'h6'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "h6:",
category: 'tags',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._h6())._with_(anObject);
return $1;
}, function($ctx1) {$ctx1.fill(self,"h6:",{anObject:anObject},smalltalk.HTMLCanvas)})},
args: ["anObject"],
source: "h6: anObject\x0a\x09^self h6 with: anObject",
messageSends: ["with:", "h6"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "head",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("head");
return $1;
}, function($ctx1) {$ctx1.fill(self,"head",{},smalltalk.HTMLCanvas)})},
args: [],
source: "head\x0a\x09^self tag: 'head'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "header",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("header");
return $1;
}, function($ctx1) {$ctx1.fill(self,"header",{},smalltalk.HTMLCanvas)})},
args: [],
source: "header\x0a\x09^self tag: 'header'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "hgroup",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("hgroup");
return $1;
}, function($ctx1) {$ctx1.fill(self,"hgroup",{},smalltalk.HTMLCanvas)})},
args: [],
source: "hgroup\x0a\x09^self tag: 'hgroup'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "hr",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("hr");
return $1;
}, function($ctx1) {$ctx1.fill(self,"hr",{},smalltalk.HTMLCanvas)})},
args: [],
source: "hr\x0a\x09^self tag: 'hr'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "html",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("html");
return $1;
}, function($ctx1) {$ctx1.fill(self,"html",{},smalltalk.HTMLCanvas)})},
args: [],
source: "html\x0a\x09^self tag: 'html'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "iframe",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("iframe");
return $1;
}, function($ctx1) {$ctx1.fill(self,"iframe",{},smalltalk.HTMLCanvas)})},
args: [],
source: "iframe\x0a\x09^self tag: 'iframe'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "iframe:",
category: 'tags',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._iframe())._src_(aString);
return $1;
}, function($ctx1) {$ctx1.fill(self,"iframe:",{aString:aString},smalltalk.HTMLCanvas)})},
args: ["aString"],
source: "iframe: aString\x0a\x09^self iframe src: aString",
messageSends: ["src:", "iframe"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "img",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("img");
return $1;
}, function($ctx1) {$ctx1.fill(self,"img",{},smalltalk.HTMLCanvas)})},
args: [],
source: "img\x0a\x09^self tag: 'img'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "img:",
category: 'tags',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._img())._src_(aString);
return $1;
}, function($ctx1) {$ctx1.fill(self,"img:",{aString:aString},smalltalk.HTMLCanvas)})},
args: ["aString"],
source: "img: aString\x0a\x09^self img src: aString",
messageSends: ["src:", "img"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "initialize",
category: 'initialization',
fn: function (){
var self=this;
function $TagBrush(){return smalltalk.TagBrush||(typeof TagBrush=="undefined"?nil:TagBrush)}
return smalltalk.withContext(function($ctx1) { 
var $1;
smalltalk.Object.fn.prototype._initialize.apply(_st(self), []);
$1=self["@root"];
if(($receiver = $1) == nil || $receiver == undefined){
self["@root"]=_st($TagBrush())._fromString_canvas_("div",self);
self["@root"];
} else {
$1;
};
return self}, function($ctx1) {$ctx1.fill(self,"initialize",{},smalltalk.HTMLCanvas)})},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09root ifNil: [root := TagBrush fromString: 'div' canvas: self]",
messageSends: ["initialize", "ifNil:", "fromString:canvas:"],
referencedClasses: ["TagBrush"]
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "initializeFromJQuery:",
category: 'initialization',
fn: function (aJQuery){
var self=this;
function $TagBrush(){return smalltalk.TagBrush||(typeof TagBrush=="undefined"?nil:TagBrush)}
return smalltalk.withContext(function($ctx1) { 
self["@root"]=_st($TagBrush())._fromJQuery_canvas_(aJQuery,self);
return self}, function($ctx1) {$ctx1.fill(self,"initializeFromJQuery:",{aJQuery:aJQuery},smalltalk.HTMLCanvas)})},
args: ["aJQuery"],
source: "initializeFromJQuery: aJQuery\x0a\x09root := TagBrush fromJQuery: aJQuery canvas: self",
messageSends: ["fromJQuery:canvas:"],
referencedClasses: ["TagBrush"]
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "input",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("input");
return $1;
}, function($ctx1) {$ctx1.fill(self,"input",{},smalltalk.HTMLCanvas)})},
args: [],
source: "input\x0a\x09^self tag: 'input'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "label",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("label");
return $1;
}, function($ctx1) {$ctx1.fill(self,"label",{},smalltalk.HTMLCanvas)})},
args: [],
source: "label\x0a\x09^self tag: 'label'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "legend",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("legend");
return $1;
}, function($ctx1) {$ctx1.fill(self,"legend",{},smalltalk.HTMLCanvas)})},
args: [],
source: "legend\x0a\x09^self tag: 'legend'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "li",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("li");
return $1;
}, function($ctx1) {$ctx1.fill(self,"li",{},smalltalk.HTMLCanvas)})},
args: [],
source: "li\x0a\x09^self tag: 'li'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "li:",
category: 'tags',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._li())._with_(anObject);
return $1;
}, function($ctx1) {$ctx1.fill(self,"li:",{anObject:anObject},smalltalk.HTMLCanvas)})},
args: ["anObject"],
source: "li: anObject\x0a\x09^self li with: anObject",
messageSends: ["with:", "li"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "link",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("link");
return $1;
}, function($ctx1) {$ctx1.fill(self,"link",{},smalltalk.HTMLCanvas)})},
args: [],
source: "link\x0a\x09^self tag: 'link'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "map",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("map");
return $1;
}, function($ctx1) {$ctx1.fill(self,"map",{},smalltalk.HTMLCanvas)})},
args: [],
source: "map\x0a\x09^self tag: 'map'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "mark",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("mark");
return $1;
}, function($ctx1) {$ctx1.fill(self,"mark",{},smalltalk.HTMLCanvas)})},
args: [],
source: "mark\x0a\x09^self tag: 'mark'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "menu",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("menu");
return $1;
}, function($ctx1) {$ctx1.fill(self,"menu",{},smalltalk.HTMLCanvas)})},
args: [],
source: "menu\x0a\x09^self tag: 'menu'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "meta",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("meta");
return $1;
}, function($ctx1) {$ctx1.fill(self,"meta",{},smalltalk.HTMLCanvas)})},
args: [],
source: "meta\x0a\x09^self tag: 'meta'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "nav",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("nav");
return $1;
}, function($ctx1) {$ctx1.fill(self,"nav",{},smalltalk.HTMLCanvas)})},
args: [],
source: "nav\x0a\x09^self tag: 'nav'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "newTag:",
category: 'tags',
fn: function (aString){
var self=this;
function $TagBrush(){return smalltalk.TagBrush||(typeof TagBrush=="undefined"?nil:TagBrush)}
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st($TagBrush())._fromString_canvas_(aString,self);
return $1;
}, function($ctx1) {$ctx1.fill(self,"newTag:",{aString:aString},smalltalk.HTMLCanvas)})},
args: ["aString"],
source: "newTag: aString\x0a\x09^TagBrush fromString: aString canvas: self",
messageSends: ["fromString:canvas:"],
referencedClasses: ["TagBrush"]
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "noscript",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("noscript");
return $1;
}, function($ctx1) {$ctx1.fill(self,"noscript",{},smalltalk.HTMLCanvas)})},
args: [],
source: "noscript\x0a\x09^self tag: 'noscript'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "object",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("object");
return $1;
}, function($ctx1) {$ctx1.fill(self,"object",{},smalltalk.HTMLCanvas)})},
args: [],
source: "object\x0a\x09^self tag: 'object'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "ol",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("ol");
return $1;
}, function($ctx1) {$ctx1.fill(self,"ol",{},smalltalk.HTMLCanvas)})},
args: [],
source: "ol\x0a\x09^self tag: 'ol'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "ol:",
category: 'tags',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._ol())._with_(anObject);
return $1;
}, function($ctx1) {$ctx1.fill(self,"ol:",{anObject:anObject},smalltalk.HTMLCanvas)})},
args: ["anObject"],
source: "ol: anObject\x0a\x09^self ol with: anObject",
messageSends: ["with:", "ol"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "optgroup",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("optgroup");
return $1;
}, function($ctx1) {$ctx1.fill(self,"optgroup",{},smalltalk.HTMLCanvas)})},
args: [],
source: "optgroup\x0a\x09^self tag: 'optgroup'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "option",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("option");
return $1;
}, function($ctx1) {$ctx1.fill(self,"option",{},smalltalk.HTMLCanvas)})},
args: [],
source: "option\x0a\x09^self tag: 'option'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "output",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("output");
return $1;
}, function($ctx1) {$ctx1.fill(self,"output",{},smalltalk.HTMLCanvas)})},
args: [],
source: "output\x0a\x09^self tag: 'output'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "p",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("p");
return $1;
}, function($ctx1) {$ctx1.fill(self,"p",{},smalltalk.HTMLCanvas)})},
args: [],
source: "p\x0a\x09^self tag: 'p'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "p:",
category: 'tags',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._p())._with_(anObject);
return $1;
}, function($ctx1) {$ctx1.fill(self,"p:",{anObject:anObject},smalltalk.HTMLCanvas)})},
args: ["anObject"],
source: "p: anObject\x0a\x09^self p with: anObject",
messageSends: ["with:", "p"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "param",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("param");
return $1;
}, function($ctx1) {$ctx1.fill(self,"param",{},smalltalk.HTMLCanvas)})},
args: [],
source: "param\x0a\x09^self tag: 'param'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "pre",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("pre");
return $1;
}, function($ctx1) {$ctx1.fill(self,"pre",{},smalltalk.HTMLCanvas)})},
args: [],
source: "pre\x0a\x09^self tag: 'pre'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "progress",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("progress");
return $1;
}, function($ctx1) {$ctx1.fill(self,"progress",{},smalltalk.HTMLCanvas)})},
args: [],
source: "progress\x0a\x09^self tag: 'progress'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "root",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@root"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"root",{},smalltalk.HTMLCanvas)})},
args: [],
source: "root\x0a\x09^root",
messageSends: [],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "root:",
category: 'accessing',
fn: function (aTagBrush){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@root"]=aTagBrush;
return self}, function($ctx1) {$ctx1.fill(self,"root:",{aTagBrush:aTagBrush},smalltalk.HTMLCanvas)})},
args: ["aTagBrush"],
source: "root: aTagBrush\x0a\x09root := aTagBrush",
messageSends: [],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "script",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("script");
return $1;
}, function($ctx1) {$ctx1.fill(self,"script",{},smalltalk.HTMLCanvas)})},
args: [],
source: "script\x0a\x09^self tag: 'script'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "section",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("section");
return $1;
}, function($ctx1) {$ctx1.fill(self,"section",{},smalltalk.HTMLCanvas)})},
args: [],
source: "section\x0a\x09^self tag: 'section'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "select",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("select");
return $1;
}, function($ctx1) {$ctx1.fill(self,"select",{},smalltalk.HTMLCanvas)})},
args: [],
source: "select\x0a\x09^self tag: 'select'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "small",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("small");
return $1;
}, function($ctx1) {$ctx1.fill(self,"small",{},smalltalk.HTMLCanvas)})},
args: [],
source: "small\x0a\x09^self tag: 'small'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "snippet:",
category: 'accessing',
fn: function (anElement){
var self=this;
var clone,caret;
function $TagBrush(){return smalltalk.TagBrush||(typeof TagBrush=="undefined"?nil:TagBrush)}
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
clone=_st(_st(anElement)._asJQuery())._clone();
_st(self)._with_(_st($TagBrush())._fromJQuery_canvas_(clone,self));
caret=_st(clone)._find_("[data-snippet=\x22*\x22]");
$1=_st(_st(caret)._toArray())._isEmpty();
if(smalltalk.assert($1)){
caret=clone;
caret;
};
$2=_st($TagBrush())._fromJQuery_canvas_(_st(caret)._removeAttr_("data-snippet"),self);
return $2;
}, function($ctx1) {$ctx1.fill(self,"snippet:",{anElement:anElement,clone:clone,caret:caret},smalltalk.HTMLCanvas)})},
args: ["anElement"],
source: "snippet: anElement\x0a\x09\x22Adds clone of anElement, finds [data-snippet=\x22\x22*\x22\x22] subelement\x0a\x09and returns TagBrush as if that subelement was just added.\x0a\x09\x0a\x09Rarely needed to use directly, use `html foo` dynamically installed method\x0a\x09for a snippet named foo.\x22\x0a\x09\x0a\x09| clone caret |\x0a\x09\x0a\x09clone := anElement asJQuery clone.\x0a\x09self with: (TagBrush fromJQuery: clone canvas: self).\x0a\x09caret := clone find: '[data-snippet=\x22*\x22]'.\x0a\x09caret toArray isEmpty ifTrue: [ caret := clone ].\x0a\x09^TagBrush fromJQuery: (caret removeAttr: 'data-snippet') canvas: self",
messageSends: ["clone", "asJQuery", "with:", "fromJQuery:canvas:", "find:", "ifTrue:", "isEmpty", "toArray", "removeAttr:"],
referencedClasses: ["TagBrush"]
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "source",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("source");
return $1;
}, function($ctx1) {$ctx1.fill(self,"source",{},smalltalk.HTMLCanvas)})},
args: [],
source: "source\x0a\x09^self tag: 'source'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "span",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("span");
return $1;
}, function($ctx1) {$ctx1.fill(self,"span",{},smalltalk.HTMLCanvas)})},
args: [],
source: "span\x0a\x09^self tag: 'span'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "span:",
category: 'tags',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._span())._with_(anObject);
return $1;
}, function($ctx1) {$ctx1.fill(self,"span:",{anObject:anObject},smalltalk.HTMLCanvas)})},
args: ["anObject"],
source: "span: anObject\x0a\x09^self span with: anObject",
messageSends: ["with:", "span"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "strong",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("strong");
return $1;
}, function($ctx1) {$ctx1.fill(self,"strong",{},smalltalk.HTMLCanvas)})},
args: [],
source: "strong\x0a\x09^self tag: 'strong'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "strong:",
category: 'tags',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._strong())._with_(anObject);
return $1;
}, function($ctx1) {$ctx1.fill(self,"strong:",{anObject:anObject},smalltalk.HTMLCanvas)})},
args: ["anObject"],
source: "strong: anObject\x0a\x09^self strong with: anObject",
messageSends: ["with:", "strong"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "style",
category: 'tags',
fn: function (){
var self=this;
function $StyleTag(){return smalltalk.StyleTag||(typeof StyleTag=="undefined"?nil:StyleTag)}
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self["@root"])._addBrush_(_st($StyleTag())._canvas_(self));
return $1;
}, function($ctx1) {$ctx1.fill(self,"style",{},smalltalk.HTMLCanvas)})},
args: [],
source: "style\x0a\x09^ root addBrush: (StyleTag canvas: self)",
messageSends: ["addBrush:", "canvas:"],
referencedClasses: ["StyleTag"]
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "style:",
category: 'tags',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._style();
_st($2)._with_(aString);
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"style:",{aString:aString},smalltalk.HTMLCanvas)})},
args: ["aString"],
source: "style: aString\x0a\x09^ self style with: aString; yourself",
messageSends: ["with:", "style", "yourself"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "sub",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("sub");
return $1;
}, function($ctx1) {$ctx1.fill(self,"sub",{},smalltalk.HTMLCanvas)})},
args: [],
source: "sub\x0a\x09^self tag: 'sub'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "summary",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("summary");
return $1;
}, function($ctx1) {$ctx1.fill(self,"summary",{},smalltalk.HTMLCanvas)})},
args: [],
source: "summary\x0a\x09^self tag: 'summary'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "sup",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("sup");
return $1;
}, function($ctx1) {$ctx1.fill(self,"sup",{},smalltalk.HTMLCanvas)})},
args: [],
source: "sup\x0a\x09^self tag: 'sup'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "table",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("table");
return $1;
}, function($ctx1) {$ctx1.fill(self,"table",{},smalltalk.HTMLCanvas)})},
args: [],
source: "table\x0a\x09^self tag: 'table'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "tag:",
category: 'tags',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self["@root"])._addBrush_(_st(self)._newTag_(aString));
return $1;
}, function($ctx1) {$ctx1.fill(self,"tag:",{aString:aString},smalltalk.HTMLCanvas)})},
args: ["aString"],
source: "tag: aString\x0a\x09^root addBrush: (self newTag: aString)",
messageSends: ["addBrush:", "newTag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "tbody",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("tbody");
return $1;
}, function($ctx1) {$ctx1.fill(self,"tbody",{},smalltalk.HTMLCanvas)})},
args: [],
source: "tbody\x0a\x09^self tag: 'tbody'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "td",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("td");
return $1;
}, function($ctx1) {$ctx1.fill(self,"td",{},smalltalk.HTMLCanvas)})},
args: [],
source: "td\x0a\x09^self tag: 'td'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "textarea",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("textarea");
return $1;
}, function($ctx1) {$ctx1.fill(self,"textarea",{},smalltalk.HTMLCanvas)})},
args: [],
source: "textarea\x0a\x09^self tag: 'textarea'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "tfoot",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("tfoot");
return $1;
}, function($ctx1) {$ctx1.fill(self,"tfoot",{},smalltalk.HTMLCanvas)})},
args: [],
source: "tfoot\x0a\x09^self tag: 'tfoot'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "th",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("th");
return $1;
}, function($ctx1) {$ctx1.fill(self,"th",{},smalltalk.HTMLCanvas)})},
args: [],
source: "th\x0a\x09^self tag: 'th'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "thead",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("thead");
return $1;
}, function($ctx1) {$ctx1.fill(self,"thead",{},smalltalk.HTMLCanvas)})},
args: [],
source: "thead\x0a\x09^self tag: 'thead'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "time",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("time");
return $1;
}, function($ctx1) {$ctx1.fill(self,"time",{},smalltalk.HTMLCanvas)})},
args: [],
source: "time\x0a\x09^self tag: 'time'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "title",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("title");
return $1;
}, function($ctx1) {$ctx1.fill(self,"title",{},smalltalk.HTMLCanvas)})},
args: [],
source: "title\x0a\x09^self tag: 'title'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "tr",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("tr");
return $1;
}, function($ctx1) {$ctx1.fill(self,"tr",{},smalltalk.HTMLCanvas)})},
args: [],
source: "tr\x0a\x09^self tag: 'tr'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "ul",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("ul");
return $1;
}, function($ctx1) {$ctx1.fill(self,"ul",{},smalltalk.HTMLCanvas)})},
args: [],
source: "ul\x0a\x09^self tag: 'ul'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "ul:",
category: 'tags',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._ul())._with_(anObject);
return $1;
}, function($ctx1) {$ctx1.fill(self,"ul:",{anObject:anObject},smalltalk.HTMLCanvas)})},
args: ["anObject"],
source: "ul: anObject\x0a\x09^self ul with: anObject",
messageSends: ["with:", "ul"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "video",
category: 'tags',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._tag_("video");
return $1;
}, function($ctx1) {$ctx1.fill(self,"video",{},smalltalk.HTMLCanvas)})},
args: [],
source: "video\x0a\x09^self tag: 'video'",
messageSends: ["tag:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "with:",
category: 'adding',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._root())._with_(anObject);
return $1;
}, function($ctx1) {$ctx1.fill(self,"with:",{anObject:anObject},smalltalk.HTMLCanvas)})},
args: ["anObject"],
source: "with: anObject\x0a\x09^self root with: anObject",
messageSends: ["with:", "root"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "workspace",
category: 'tags',
fn: function (){
var self=this;
function $WorkspaceMorph(){return smalltalk.WorkspaceMorph||(typeof WorkspaceMorph=="undefined"?nil:WorkspaceMorph)}
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self["@root"])._addBrush_(_st($WorkspaceMorph())._canvas_(self));
return $1;
}, function($ctx1) {$ctx1.fill(self,"workspace",{},smalltalk.HTMLCanvas)})},
args: [],
source: "workspace\x0a\x09^ root addBrush: (WorkspaceMorph canvas: self)",
messageSends: ["addBrush:", "canvas:"],
referencedClasses: ["WorkspaceMorph"]
}),
smalltalk.HTMLCanvas);

smalltalk.addMethod(
smalltalk.method({
selector: "workspace:",
category: 'tags',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._workspace();
_st($2)._with_(aString);
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"workspace:",{aString:aString},smalltalk.HTMLCanvas)})},
args: ["aString"],
source: "workspace: aString\x0a\x09^ self workspace with: aString; yourself",
messageSends: ["with:", "workspace", "yourself"],
referencedClasses: []
}),
smalltalk.HTMLCanvas);


smalltalk.addMethod(
smalltalk.method({
selector: "browserVersion",
category: 'instance creation',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(jQuery)._at_("browser"))._version();
return $1;
}, function($ctx1) {$ctx1.fill(self,"browserVersion",{},smalltalk.HTMLCanvas.klass)})},
args: [],
source: "browserVersion\x0a\x09^(jQuery at: #browser) version",
messageSends: ["version", "at:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "isMSIE",
category: 'instance creation',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(jQuery)._at_("browser"))._at_("msie"))._notNil();
return $1;
}, function($ctx1) {$ctx1.fill(self,"isMSIE",{},smalltalk.HTMLCanvas.klass)})},
args: [],
source: "isMSIE\x0a\x09^((jQuery at: #browser) at: #msie) notNil",
messageSends: ["notNil", "at:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "isMozilla",
category: 'instance creation',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(jQuery)._at_("browser"))._at_("mozilla"))._notNil();
return $1;
}, function($ctx1) {$ctx1.fill(self,"isMozilla",{},smalltalk.HTMLCanvas.klass)})},
args: [],
source: "isMozilla\x0a\x09^((jQuery at: #browser) at: #mozilla) notNil",
messageSends: ["notNil", "at:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "isOpera",
category: 'instance creation',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(jQuery)._at_("browser"))._at_("opera"))._notNil();
return $1;
}, function($ctx1) {$ctx1.fill(self,"isOpera",{},smalltalk.HTMLCanvas.klass)})},
args: [],
source: "isOpera\x0a\x09^((jQuery at: #browser) at: #opera) notNil",
messageSends: ["notNil", "at:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "isWebkit",
category: 'instance creation',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(jQuery)._at_("browser"))._at_("webkit"))._notNil();
return $1;
}, function($ctx1) {$ctx1.fill(self,"isWebkit",{},smalltalk.HTMLCanvas.klass)})},
args: [],
source: "isWebkit\x0a\x09^((jQuery at: #browser) at: #webkit) notNil",
messageSends: ["notNil", "at:"],
referencedClasses: []
}),
smalltalk.HTMLCanvas.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "onJQuery:",
category: 'instance creation',
fn: function (aJQuery){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._basicNew();
_st($2)._initializeFromJQuery_(aJQuery);
_st($2)._initialize();
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"onJQuery:",{aJQuery:aJQuery},smalltalk.HTMLCanvas.klass)})},
args: ["aJQuery"],
source: "onJQuery: aJQuery\x0a\x09^self basicNew\x0a\x09\x09initializeFromJQuery: aJQuery;\x0a\x09\x09initialize;\x0a\x09\x09yourself",
messageSends: ["initializeFromJQuery:", "basicNew", "initialize", "yourself"],
referencedClasses: []
}),
smalltalk.HTMLCanvas.klass);


smalltalk.addClass('HTMLSnippet', smalltalk.Object, ['snippets'], 'Canvas');
smalltalk.HTMLSnippet.comment="HTMLSnippet instance is the registry of html snippets.\x0aHTMLSnippet current is the public singleton instance.\x0a\x0aAt the beginning, it scans the document for any html elements\x0awith 'data-snippet=\x22foo\x22' attribute and takes them off the document,\x0aremembering them in the store under the specified name.\x0aIt also install method #foo into HTMLCanvas dynamically.\x0a\x0aEvery html snippet should mark a 'caret', a place where contents\x0acan be inserted, by 'data-snippet=\x22*\x22' (a special name for caret).\x0aFor example:\x0a\x0a<li data-snippet='menuelement' class='...'><a data-snippet='*'></a></li>\x0a\x0adefines a list element with a link inside; the link itself is marked as a caret.\x0a\x0aYou can later issue\x0a\x0ahtml menuelement href: '/foo'; with: 'A foo'\x0a\x0ato insert the whole snippet and directly manipulate the caret, so it renders:\x0a\x0a<li class='...'><a href='/foo'>A foo</a></li>\x0a\x0aFor a self-careting tags (not very useful, but you do not need to fill class etc.\x0ayou can use\x0a\x0a<div class='lots of classes' attr1='one' attr2='two' data-snippet='*bar'></div>\x0a\x0aand in code later do:\x0a\x0ahtml bar with: [ xxx ]\x0a\x0ato render\x0a\x0a<div class='lots of classes' attr1='one' attr2='two'>...added by xxx...</div>"
smalltalk.addMethod(
smalltalk.method({
selector: "initializeFromJQuery:",
category: 'initialization',
fn: function (aJQuery){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._snippetsFromJQuery_(aJQuery))._do_((function(each){
return smalltalk.withContext(function($ctx2) {
return _st(self)._installSnippetFromJQuery_(_st(each)._asJQuery());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1)})}));
return self}, function($ctx1) {$ctx1.fill(self,"initializeFromJQuery:",{aJQuery:aJQuery},smalltalk.HTMLSnippet)})},
args: ["aJQuery"],
source: "initializeFromJQuery: aJQuery\x0a\x09\x22Finds and takes out all snippets out of aJQuery.\x0a\x09Installs it into self.\x22\x0a\x09\x0a\x09(self snippetsFromJQuery: aJQuery) do: [ :each |\x0a\x09\x09self installSnippetFromJQuery: each asJQuery ]",
messageSends: ["do:", "installSnippetFromJQuery:", "asJQuery", "snippetsFromJQuery:"],
referencedClasses: []
}),
smalltalk.HTMLSnippet);

smalltalk.addMethod(
smalltalk.method({
selector: "installSnippetFromJQuery:",
category: 'snippet installation',
fn: function (element){
var self=this;
var name;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
name=_st(element)._attr_("data-snippet");
$1=_st(name).__eq("*");
if(! smalltalk.assert($1)){
$2=_st(_st("^\x5c*")._asRegexp())._test_(name);
if(smalltalk.assert($2)){
name=_st(name)._allButFirst();
name;
_st(element)._attr_put_("data-snippet","*");
} else {
_st(element)._removeAttr_("data-snippet");
};
_st(self)._snippetAt_install_(name,_st(_st(element)._detach())._get_((0)));
};
return self}, function($ctx1) {$ctx1.fill(self,"installSnippetFromJQuery:",{element:element,name:name},smalltalk.HTMLSnippet)})},
args: ["element"],
source: "installSnippetFromJQuery: element\x0a\x09| name |\x0a\x09name := element attr: 'data-snippet'.\x0a\x09name = '*' ifFalse: [\x0a\x09\x09('^\x5c*' asRegexp test: name)\x0a\x09\x09\x09ifTrue: [\x0a\x09\x09\x09\x09name := name allButFirst.\x0a\x09\x09\x09\x09element attr: 'data-snippet' put: '*' ]\x0a\x09\x09\x09ifFalse: [\x0a\x09\x09\x09\x09element removeAttr: 'data-snippet' ].\x0a\x09\x09self snippetAt: name install: (element detach get: 0) ]",
messageSends: ["attr:", "ifFalse:", "ifTrue:ifFalse:", "allButFirst", "attr:put:", "removeAttr:", "test:", "asRegexp", "snippetAt:install:", "get:", "detach", "="],
referencedClasses: []
}),
smalltalk.HTMLSnippet);

smalltalk.addMethod(
smalltalk.method({
selector: "snippetAt:",
category: 'accessing',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._snippets())._at_(aString);
return $1;
}, function($ctx1) {$ctx1.fill(self,"snippetAt:",{aString:aString},smalltalk.HTMLSnippet)})},
args: ["aString"],
source: "snippetAt: aString\x0a\x09^ self snippets at: aString",
messageSends: ["at:", "snippets"],
referencedClasses: []
}),
smalltalk.HTMLSnippet);

smalltalk.addMethod(
smalltalk.method({
selector: "snippetAt:compile:",
category: 'method generation',
fn: function (aString,anElement){
var self=this;
function $HTMLCanvas(){return smalltalk.HTMLCanvas||(typeof HTMLCanvas=="undefined"?nil:HTMLCanvas)}
function $ClassBuilder(){return smalltalk.ClassBuilder||(typeof ClassBuilder=="undefined"?nil:ClassBuilder)}
return smalltalk.withContext(function($ctx1) { 
_st(_st($ClassBuilder())._new())._installMethod_forClass_category_(_st(_st((function(htmlReceiver){
return smalltalk.withContext(function($ctx2) {
return _st(htmlReceiver)._snippet_(anElement);
}, function($ctx2) {$ctx2.fillBlock({htmlReceiver:htmlReceiver},$ctx1)})}))._currySelf())._asCompiledMethod_(aString),$HTMLCanvas(),"**snippets");
return self}, function($ctx1) {$ctx1.fill(self,"snippetAt:compile:",{aString:aString,anElement:anElement},smalltalk.HTMLSnippet)})},
args: ["aString", "anElement"],
source: "snippetAt: aString compile: anElement\x0a\x09\x22Method generation for the snippet.\x0a\x09The selector is aString, the method block uses anElement\x22\x0a\x09\x0a\x09ClassBuilder new\x0a\x09\x09installMethod: ([ :htmlReceiver | htmlReceiver snippet: anElement ]\x0a\x09\x09\x09currySelf asCompiledMethod: aString)\x0a\x09\x09forClass: HTMLCanvas\x0a\x09\x09category: '**snippets'",
messageSends: ["installMethod:forClass:category:", "asCompiledMethod:", "currySelf", "snippet:", "new"],
referencedClasses: ["HTMLCanvas", "ClassBuilder"]
}),
smalltalk.HTMLSnippet);

smalltalk.addMethod(
smalltalk.method({
selector: "snippetAt:install:",
category: 'snippet installation',
fn: function (aString,anElement){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._snippets())._at_put_(aString,anElement);
_st(self)._snippetAt_compile_(aString,anElement);
return self}, function($ctx1) {$ctx1.fill(self,"snippetAt:install:",{aString:aString,anElement:anElement},smalltalk.HTMLSnippet)})},
args: ["aString", "anElement"],
source: "snippetAt: aString install: anElement\x0a\x09self snippets at: aString put: anElement.\x0a\x09self snippetAt: aString compile: anElement",
messageSends: ["at:put:", "snippets", "snippetAt:compile:"],
referencedClasses: []
}),
smalltalk.HTMLSnippet);

smalltalk.addMethod(
smalltalk.method({
selector: "snippets",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$1;
$2=self["@snippets"];
if(($receiver = $2) == nil || $receiver == undefined){
self["@snippets"]=smalltalk.HashedCollection._fromPairs_([]);
$1=self["@snippets"];
} else {
$1=$2;
};
return $1;
}, function($ctx1) {$ctx1.fill(self,"snippets",{},smalltalk.HTMLSnippet)})},
args: [],
source: "snippets\x0a\x09^snippets ifNil: [ snippets := #{} ]",
messageSends: ["ifNil:"],
referencedClasses: []
}),
smalltalk.HTMLSnippet);

smalltalk.addMethod(
smalltalk.method({
selector: "snippetsFromJQuery:",
category: 'private',
fn: function (aJQuery){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(aJQuery)._find_("[data-snippet]"))._toArray();
return $1;
}, function($ctx1) {$ctx1.fill(self,"snippetsFromJQuery:",{aJQuery:aJQuery},smalltalk.HTMLSnippet)})},
args: ["aJQuery"],
source: "snippetsFromJQuery: aJQuery\x0a\x09^ (aJQuery find: '[data-snippet]') toArray",
messageSends: ["toArray", "find:"],
referencedClasses: []
}),
smalltalk.HTMLSnippet);


smalltalk.HTMLSnippet.klass.iVarNames = ['current'];
smalltalk.addMethod(
smalltalk.method({
selector: "current",
category: 'instance creation',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@current"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"current",{},smalltalk.HTMLSnippet.klass)})},
args: [],
source: "current\x0a\x09^ current",
messageSends: [],
referencedClasses: []
}),
smalltalk.HTMLSnippet.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "ensureCurrent",
category: 'initialization',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2,$3;
$1=self["@current"];
if(($receiver = $1) == nil || $receiver == undefined){
$2=smalltalk.Object.klass.fn.prototype._new.apply(_st(self), []);
_st($2)._initializeFromJQuery_(_st(document)._asJQuery());
$3=_st($2)._yourself();
self["@current"]=$3;
self["@current"];
} else {
$1;
};
return self}, function($ctx1) {$ctx1.fill(self,"ensureCurrent",{},smalltalk.HTMLSnippet.klass)})},
args: [],
source: "ensureCurrent\x0a\x09current ifNil: [\x0a\x09\x09current := super new\x0a\x09\x09\x09initializeFromJQuery: document asJQuery;\x0a\x09\x09\x09yourself ]",
messageSends: ["ifNil:", "initializeFromJQuery:", "asJQuery", "new", "yourself"],
referencedClasses: []
}),
smalltalk.HTMLSnippet.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "initialize",
category: 'initialization',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
smalltalk.Object.klass.fn.prototype._initialize.apply(_st(self), []);
$1=_st(self)._isDOMAvailable();
if(smalltalk.assert($1)){
_st(self)._ensureCurrent();
};
return self}, function($ctx1) {$ctx1.fill(self,"initialize",{},smalltalk.HTMLSnippet.klass)})},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09self isDOMAvailable ifTrue: [\x0a\x09\x09self ensureCurrent ]",
messageSends: ["initialize", "ifTrue:", "ensureCurrent", "isDOMAvailable"],
referencedClasses: []
}),
smalltalk.HTMLSnippet.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "isDOMAvailable",
category: 'instance creation',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
 return typeof document !== 'undefined' ;
return self}, function($ctx1) {$ctx1.fill(self,"isDOMAvailable",{},smalltalk.HTMLSnippet.klass)})},
args: [],
source: "isDOMAvailable\x0a\x09< return typeof document !== 'undefined' >",
messageSends: [],
referencedClasses: []
}),
smalltalk.HTMLSnippet.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "new",
category: 'instance creation',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._shouldNotImplement();
return self}, function($ctx1) {$ctx1.fill(self,"new",{},smalltalk.HTMLSnippet.klass)})},
args: [],
source: "new\x0a\x09self shouldNotImplement",
messageSends: ["shouldNotImplement"],
referencedClasses: []
}),
smalltalk.HTMLSnippet.klass);


smalltalk.addClass('KeyboardEvent', smalltalk.Object, ['keyValue'], 'Canvas');
smalltalk.addMethod(
smalltalk.method({
selector: "altKeyPressed",
category: 'modifier keys',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._commandKeyPressed();
return $1;
}, function($ctx1) {$ctx1.fill(self,"altKeyPressed",{},smalltalk.KeyboardEvent)})},
args: [],
source: "altKeyPressed\x0a\x09^ self commandKeyPressed",
messageSends: ["commandKeyPressed"],
referencedClasses: []
}),
smalltalk.KeyboardEvent);

smalltalk.addMethod(
smalltalk.method({
selector: "commandKeyPressed",
category: 'modifier keys',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
return false;
}, function($ctx1) {$ctx1.fill(self,"commandKeyPressed",{},smalltalk.KeyboardEvent)})},
args: [],
source: "commandKeyPressed\x0a\x09\x22TODO: implement\x22\x0a\x09^ false",
messageSends: [],
referencedClasses: []
}),
smalltalk.KeyboardEvent);

smalltalk.addMethod(
smalltalk.method({
selector: "keyCharacter",
category: 'accessing',
fn: function (){
var self=this;
function $Character(){return smalltalk.Character||(typeof Character=="undefined"?nil:Character)}
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st($Character())._codePoint_(_st(self)._keyValue());
return $1;
}, function($ctx1) {$ctx1.fill(self,"keyCharacter",{},smalltalk.KeyboardEvent)})},
args: [],
source: "keyCharacter\x0a\x09^ Character codePoint: self keyValue",
messageSends: ["codePoint:", "keyValue"],
referencedClasses: ["Character"]
}),
smalltalk.KeyboardEvent);

smalltalk.addMethod(
smalltalk.method({
selector: "keyValue",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@keyValue"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"keyValue",{},smalltalk.KeyboardEvent)})},
args: [],
source: "keyValue\x0a\x09^ keyValue",
messageSends: [],
referencedClasses: []
}),
smalltalk.KeyboardEvent);

smalltalk.addMethod(
smalltalk.method({
selector: "keyValue:",
category: 'accessing',
fn: function (anInteger){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@keyValue"]=anInteger;
return self}, function($ctx1) {$ctx1.fill(self,"keyValue:",{anInteger:anInteger},smalltalk.KeyboardEvent)})},
args: ["anInteger"],
source: "keyValue: anInteger\x0a\x09keyValue := anInteger.",
messageSends: [],
referencedClasses: []
}),
smalltalk.KeyboardEvent);


smalltalk.addMethod(
smalltalk.method({
selector: "value:",
category: 'instance creation',
fn: function (anInteger){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._new();
_st($2)._keyValue_(anInteger);
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"value:",{anInteger:anInteger},smalltalk.KeyboardEvent.klass)})},
args: ["anInteger"],
source: "value: anInteger\x0a\x09^ self new\x0a\x09\x09keyValue: anInteger;\x0a\x09\x09yourself",
messageSends: ["keyValue:", "new", "yourself"],
referencedClasses: []
}),
smalltalk.KeyboardEvent.klass);


smalltalk.addClass('SmalltalkEditor', smalltalk.Object, ['morph'], 'Canvas');
smalltalk.addMethod(
smalltalk.method({
selector: "accept",
category: 'events',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morph())._owner())._accept();
return self}, function($ctx1) {$ctx1.fill(self,"accept",{},smalltalk.SmalltalkEditor)})},
args: [],
source: "accept\x0a\x09self morph owner accept.",
messageSends: ["accept", "owner", "morph"],
referencedClasses: []
}),
smalltalk.SmalltalkEditor);

smalltalk.addMethod(
smalltalk.method({
selector: "keyStroke:",
category: 'events',
fn: function (evt){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(evt)._keyValue()).__eq((13));
if(smalltalk.assert($1)){
_st(self)._accept();
};
return self}, function($ctx1) {$ctx1.fill(self,"keyStroke:",{evt:evt},smalltalk.SmalltalkEditor)})},
args: ["evt"],
source: "keyStroke: evt\x0a\x09evt keyValue = 13 ifTrue: [self accept].",
messageSends: ["ifTrue:", "accept", "=", "keyValue"],
referencedClasses: []
}),
smalltalk.SmalltalkEditor);

smalltalk.addMethod(
smalltalk.method({
selector: "morph",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@morph"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"morph",{},smalltalk.SmalltalkEditor)})},
args: [],
source: "morph\x0a\x09^ morph",
messageSends: [],
referencedClasses: []
}),
smalltalk.SmalltalkEditor);

smalltalk.addMethod(
smalltalk.method({
selector: "morph:",
category: 'accessing',
fn: function (aMorph){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@morph"]=aMorph;
return self}, function($ctx1) {$ctx1.fill(self,"morph:",{aMorph:aMorph},smalltalk.SmalltalkEditor)})},
args: ["aMorph"],
source: "morph: aMorph\x0a\x09morph := aMorph",
messageSends: [],
referencedClasses: []
}),
smalltalk.SmalltalkEditor);

smalltalk.addMethod(
smalltalk.method({
selector: "selectFrom:to:",
category: 'interactions',
fn: function (start,end){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._morph())._setSelectionFrom_to_(start,end);
return self}, function($ctx1) {$ctx1.fill(self,"selectFrom:to:",{start:start,end:end},smalltalk.SmalltalkEditor)})},
args: ["start", "end"],
source: "selectFrom: start to: end\x0a\x09self morph setSelectionFrom: start to: end.",
messageSends: ["setSelectionFrom:to:", "morph"],
referencedClasses: []
}),
smalltalk.SmalltalkEditor);

smalltalk.addMethod(
smalltalk.method({
selector: "selectionInterval",
category: 'interactions',
fn: function (){
var self=this;
function $Interval(){return smalltalk.Interval||(typeof Interval=="undefined"?nil:Interval)}
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st($Interval())._from_to_(_st(_st(self)._morph())._selectionStart(),_st(_st(self)._morph())._selectionEnd());
return $1;
}, function($ctx1) {$ctx1.fill(self,"selectionInterval",{},smalltalk.SmalltalkEditor)})},
args: [],
source: "selectionInterval\x0a\x09^ Interval from: self morph selectionStart to: self morph selectionEnd",
messageSends: ["from:to:", "selectionStart", "morph", "selectionEnd"],
referencedClasses: ["Interval"]
}),
smalltalk.SmalltalkEditor);


smalltalk.addMethod(
smalltalk.method({
selector: "forMorph:",
category: 'instance creation',
fn: function (aTextMorph){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._new();
_st($2)._morph_(aTextMorph);
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"forMorph:",{aTextMorph:aTextMorph},smalltalk.SmalltalkEditor.klass)})},
args: ["aTextMorph"],
source: "forMorph: aTextMorph\x0a\x09^ self new\x0a\x09\x09morph: aTextMorph;\x0a\x09\x09yourself",
messageSends: ["morph:", "new", "yourself"],
referencedClasses: []
}),
smalltalk.SmalltalkEditor.klass);


smalltalk.addClass('TagBrush', smalltalk.Object, ['canvas', 'element'], 'Canvas');
smalltalk.addMethod(
smalltalk.method({
selector: "accesskey:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("accesskey",aString);
return self}, function($ctx1) {$ctx1.fill(self,"accesskey:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "accesskey: aString\x0a\x09self at: 'accesskey' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "action:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("action",aString);
return self}, function($ctx1) {$ctx1.fill(self,"action:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "action: aString\x0a\x09self at: 'action' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "addBrush:",
category: 'adding',
fn: function (aTagBrush){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
_st(self)._appendChild_(_st(aTagBrush)._element());
$1=aTagBrush;
return $1;
}, function($ctx1) {$ctx1.fill(self,"addBrush:",{aTagBrush:aTagBrush},smalltalk.TagBrush)})},
args: ["aTagBrush"],
source: "addBrush: aTagBrush\x0a\x09self appendChild: aTagBrush element.\x0a\x09^aTagBrush",
messageSends: ["appendChild:", "element"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "addClass:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._element())._asJQuery())._addClass_(aString);
return self}, function($ctx1) {$ctx1.fill(self,"addClass:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "addClass: aString\x0a\x09self element asJQuery addClass: aString",
messageSends: ["addClass:", "asJQuery", "element"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "align:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("align",aString);
return self}, function($ctx1) {$ctx1.fill(self,"align:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "align: aString\x0a\x09self at: 'align' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "alt:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("alt",aString);
return self}, function($ctx1) {$ctx1.fill(self,"alt:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "alt: aString\x0a\x09self at: 'alt' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "append:",
category: 'adding',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(anObject)._appendToBrush_(self);
return self}, function($ctx1) {$ctx1.fill(self,"append:",{anObject:anObject},smalltalk.TagBrush)})},
args: ["anObject"],
source: "append: anObject\x0a\x09anObject appendToBrush: self",
messageSends: ["appendToBrush:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "appendBlock:",
category: 'adding',
fn: function (aBlock){
var self=this;
var root;
return smalltalk.withContext(function($ctx1) { 
root=_st(self["@canvas"])._root();
_st(self["@canvas"])._root_(self);
_st(aBlock)._value_(self["@canvas"]);
_st(self["@canvas"])._root_(root);
return self}, function($ctx1) {$ctx1.fill(self,"appendBlock:",{aBlock:aBlock,root:root},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "appendBlock: aBlock\x0a\x09| root |\x0a\x09root := canvas root.\x0a\x09canvas root: self.\x0a\x09aBlock value: canvas.\x0a\x09canvas root: root",
messageSends: ["root", "root:", "value:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "appendChild:",
category: 'adding',
fn: function (anElement){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var element=self['@element'];
	if (null == element.canHaveChildren || element.canHaveChildren) {
		element.appendChild(anElement);
	} else {
		element.text = String(element.text) + anElement.innerHTML;
	} ;
return self}, function($ctx1) {$ctx1.fill(self,"appendChild:",{anElement:anElement},smalltalk.TagBrush)})},
args: ["anElement"],
source: "appendChild: anElement\x0a\x09\x22In IE7 and IE8 appendChild fails on several node types. So we need to check\x22\x0a\x09<var element=self['@element'];\x0a\x09if (null == element.canHaveChildren || element.canHaveChildren) {\x0a\x09\x09element.appendChild(anElement);\x0a\x09} else {\x0a\x09\x09element.text = String(element.text) + anElement.innerHTML;\x0a\x09} >",
messageSends: [],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "appendString:",
category: 'adding',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._appendChild_(_st(self)._createTextNodeFor_(aString));
return self}, function($ctx1) {$ctx1.fill(self,"appendString:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "appendString: aString\x0a\x09self appendChild: (self createTextNodeFor: aString)",
messageSends: ["appendChild:", "createTextNodeFor:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "appendToBrush:",
category: 'adding',
fn: function (aTagBrush){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(aTagBrush)._addBrush_(self);
return self}, function($ctx1) {$ctx1.fill(self,"appendToBrush:",{aTagBrush:aTagBrush},smalltalk.TagBrush)})},
args: ["aTagBrush"],
source: "appendToBrush: aTagBrush\x0a\x09aTagBrush addBrush: self",
messageSends: ["addBrush:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "asJQuery",
category: 'converting',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(window)._jQuery_(_st(self)._element());
return $1;
}, function($ctx1) {$ctx1.fill(self,"asJQuery",{},smalltalk.TagBrush)})},
args: [],
source: "asJQuery\x0a\x09^window jQuery: self element",
messageSends: ["jQuery:", "element"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "at:put:",
category: 'attributes',
fn: function (aString,aValue){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self['@element'].setAttribute(aString, aValue);
return self}, function($ctx1) {$ctx1.fill(self,"at:put:",{aString:aString,aValue:aValue},smalltalk.TagBrush)})},
args: ["aString", "aValue"],
source: "at: aString put: aValue\x0a\x09<self['@element'].setAttribute(aString, aValue)>",
messageSends: [],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "class:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self['@element'].className = aString;
return self}, function($ctx1) {$ctx1.fill(self,"class:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "class: aString\x0a\x09<self['@element'].className = aString>",
messageSends: [],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "cols:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("cols",aString);
return self}, function($ctx1) {$ctx1.fill(self,"cols:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "cols: aString\x0a\x09self at: 'cols' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "contentEditable:",
category: 'attributes',
fn: function (aBoolean){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("contenteditable",_st(aBoolean)._asString());
return self}, function($ctx1) {$ctx1.fill(self,"contentEditable:",{aBoolean:aBoolean},smalltalk.TagBrush)})},
args: ["aBoolean"],
source: "contentEditable: aBoolean\x0a\x09self at: 'contenteditable' put: aBoolean asString",
messageSends: ["at:put:", "asString"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "contenteditable:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("contenteditable",aString);
return self}, function($ctx1) {$ctx1.fill(self,"contenteditable:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "contenteditable: aString\x0a\x09self at: 'contenteditable' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "contents:",
category: 'adding',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
$1=self;
_st($1)._empty();
$2=_st($1)._append_(anObject);
return self}, function($ctx1) {$ctx1.fill(self,"contents:",{anObject:anObject},smalltalk.TagBrush)})},
args: ["anObject"],
source: "contents: anObject\x0a\x09self\x0a\x09empty;\x0a\x09append: anObject",
messageSends: ["empty", "append:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "contextmenu:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("contextmenu",aString);
return self}, function($ctx1) {$ctx1.fill(self,"contextmenu:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "contextmenu: aString\x0a\x09self at: 'contextmenu' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "createElementFor:",
category: 'private',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
return document.createElement(String(aString));
return self}, function($ctx1) {$ctx1.fill(self,"createElementFor:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "createElementFor: aString\x0a\x09<return document.createElement(String(aString))>",
messageSends: [],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "createTextNodeFor:",
category: 'private',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
return document.createTextNode(String(aString));
return self}, function($ctx1) {$ctx1.fill(self,"createTextNodeFor:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "createTextNodeFor: aString\x0a\x09<return document.createTextNode(String(aString))>",
messageSends: [],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "css:value:",
category: 'attributes',
fn: function (aProperty,aValue){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._element())._asJQuery())._css_a_(aProperty,aValue);
return self}, function($ctx1) {$ctx1.fill(self,"css:value:",{aProperty:aProperty,aValue:aValue},smalltalk.TagBrush)})},
args: ["aProperty", "aValue"],
source: "css:aProperty value:aValue\x0a\x09self element asJQuery css: aProperty a: aValue",
messageSends: ["css:a:", "asJQuery", "element"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "draggable",
category: 'attributes',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
 $(self._element()).draggable({cancel: '.drag-stop'}); ;
return self}, function($ctx1) {$ctx1.fill(self,"draggable",{},smalltalk.TagBrush)})},
args: [],
source: "draggable\x0a\x09< $(self._element()).draggable({cancel: '.drag-stop'}); >",
messageSends: [],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "draggable:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("draggable",aString);
return self}, function($ctx1) {$ctx1.fill(self,"draggable:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "draggable: aString\x0a\x09self at: 'draggable' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "element",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@element"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"element",{},smalltalk.TagBrush)})},
args: [],
source: "element\x0a\x09^element",
messageSends: [],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "empty",
category: 'adding',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._empty();
return self}, function($ctx1) {$ctx1.fill(self,"empty",{},smalltalk.TagBrush)})},
args: [],
source: "empty\x0a\x09self asJQuery empty",
messageSends: ["empty", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "for:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("for",aString);
return self}, function($ctx1) {$ctx1.fill(self,"for:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "for: aString\x0a\x09self at: 'for' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "height:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("height",aString);
return self}, function($ctx1) {$ctx1.fill(self,"height:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "height: aString\x0a\x09self at: 'height' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "hidden",
category: 'attributes',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("hidden","hidden");
return self}, function($ctx1) {$ctx1.fill(self,"hidden",{},smalltalk.TagBrush)})},
args: [],
source: "hidden\x0a\x09self at: 'hidden' put: 'hidden'",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "href:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("href",aString);
return self}, function($ctx1) {$ctx1.fill(self,"href:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "href: aString\x0a\x09self at: 'href' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "id:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("id",aString);
return self}, function($ctx1) {$ctx1.fill(self,"id:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "id: aString\x0a\x09self at: 'id' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "initializeFromJQuery:canvas:",
category: 'initialization',
fn: function (aJQuery,aCanvas){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@element"]=_st(aJQuery)._get_((0));
self["@canvas"]=aCanvas;
return self}, function($ctx1) {$ctx1.fill(self,"initializeFromJQuery:canvas:",{aJQuery:aJQuery,aCanvas:aCanvas},smalltalk.TagBrush)})},
args: ["aJQuery", "aCanvas"],
source: "initializeFromJQuery: aJQuery canvas: aCanvas\x0a\x09element := aJQuery get: 0.\x0a\x09canvas := aCanvas",
messageSends: ["get:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "initializeFromString:canvas:",
category: 'initialization',
fn: function (aString,aCanvas){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@element"]=_st(self)._createElementFor_(aString);
self["@canvas"]=aCanvas;
return self}, function($ctx1) {$ctx1.fill(self,"initializeFromString:canvas:",{aString:aString,aCanvas:aCanvas},smalltalk.TagBrush)})},
args: ["aString", "aCanvas"],
source: "initializeFromString: aString canvas: aCanvas\x0a\x09element := self createElementFor: aString.\x0a\x09canvas := aCanvas",
messageSends: ["createElementFor:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "media:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("media",aString);
return self}, function($ctx1) {$ctx1.fill(self,"media:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "media: aString\x0a\x09self at: 'media' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "method:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("method",aString);
return self}, function($ctx1) {$ctx1.fill(self,"method:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "method: aString\x0a\x09self at: 'method' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "name:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("name",aString);
return self}, function($ctx1) {$ctx1.fill(self,"name:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "name: aString\x0a\x09self at: 'name' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onArrowKeyDown:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
_st(self)._onKeyDown_((function(e){
return smalltalk.withContext(function($ctx2) {
_st(e)._preventDefault();
$1=_st(_st(e)._keyCode()).__eq((40));
if(smalltalk.assert($1)){
return _st(aBlock)._value();
};
}, function($ctx2) {$ctx2.fillBlock({e:e},$ctx1)})}));
return self}, function($ctx1) {$ctx1.fill(self,"onArrowKeyDown:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onArrowKeyDown: aBlock\x0a\x09self onKeyDown: [:e| e preventDefault. e keyCode = 40 ifTrue:[aBlock value]]",
messageSends: ["onKeyDown:", "preventDefault", "ifTrue:", "value", "=", "keyCode"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onArrowKeyUp:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
_st(self)._onKeyDown_((function(e){
return smalltalk.withContext(function($ctx2) {
_st(e)._preventDefault();
$1=_st(_st(e)._keyCode()).__eq((38));
if(smalltalk.assert($1)){
return _st(aBlock)._value();
};
}, function($ctx2) {$ctx2.fillBlock({e:e},$ctx1)})}));
return self}, function($ctx1) {$ctx1.fill(self,"onArrowKeyUp:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onArrowKeyUp: aBlock\x0a\x09self onKeyDown: [:e| e preventDefault. e keyCode = 38 ifTrue:[aBlock value]]",
messageSends: ["onKeyDown:", "preventDefault", "ifTrue:", "value", "=", "keyCode"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onBlur:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("blur",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onBlur:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onBlur: aBlock\x0a\x09self asJQuery bind: 'blur' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onChange:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("change",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onChange:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onChange: aBlock\x0a\x09self asJQuery bind: 'change' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onClick:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("click",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onClick:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onClick: aBlock\x0a\x09self asJQuery bind: 'click' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onDblClick:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("dblclick",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onDblClick:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onDblClick: aBlock\x0a\x09self asJQuery bind: 'dblclick' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onFocus:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("focus",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onFocus:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onFocus: aBlock\x0a\x09self asJQuery bind: 'focus' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onFocusIn:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("focusin",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onFocusIn:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onFocusIn: aBlock\x0a\x09self asJQuery bind: 'focusin' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onFocusOut:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("focusout",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onFocusOut:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onFocusOut: aBlock\x0a\x09self asJQuery bind: 'focusout' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onHover:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("hover",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onHover:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onHover: aBlock\x0a\x09self asJQuery bind: 'hover' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onKeyDown:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("keydown",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onKeyDown:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onKeyDown: aBlock\x0a\x09self asJQuery bind: 'keydown' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onKeyPress:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("keypress",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onKeyPress:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onKeyPress: aBlock\x0a\x09self asJQuery bind: 'keypress' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onKeyUp:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("keyup",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onKeyUp:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onKeyUp: aBlock\x0a\x09self asJQuery bind: 'keyup' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onMouseDown:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("mousedown",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onMouseDown:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onMouseDown: aBlock\x0a\x09self asJQuery bind: 'mousedown' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onMouseEnter:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("mouseenter",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onMouseEnter:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onMouseEnter: aBlock\x0a\x09self asJQuery bind: 'mouseenter' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onMouseLeave:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("mouseleave",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onMouseLeave:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onMouseLeave: aBlock\x0a\x09self asJQuery bind: 'mouseleave' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onMouseMove:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("mousemove",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onMouseMove:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onMouseMove: aBlock\x0a\x09self asJQuery bind: 'mousemove' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onMouseOut:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("mouseout",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onMouseOut:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onMouseOut: aBlock\x0a\x09self asJQuery bind: 'mouseout' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onMouseOver:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("mouseover",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onMouseOver:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onMouseOver: aBlock\x0a\x09self asJQuery bind: 'mouseover' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onMouseUp:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("mouseup",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onMouseUp:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onMouseUp: aBlock\x0a\x09self asJQuery bind: 'mouseup' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onResize:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("resize",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onResize:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onResize: aBlock\x0a\x09self asJQuery bind: 'resize' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onSelect:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("select",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onSelect:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onSelect: aBlock\x0a\x09self asJQuery bind: 'select' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onSelected:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("selectableselected",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onSelected:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onSelected: aBlock\x0a\x09self asJQuery bind: 'selectableselected' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onStop:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("selectablestop",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onStop:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onStop: aBlock\x0a\x09self asJQuery bind: 'selectablestop' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onSubmit:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("submit",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onSubmit:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onSubmit: aBlock\x0a\x09self asJQuery bind: 'submit' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "onUnload:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._bind_do_("unload",aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"onUnload:",{aBlock:aBlock},smalltalk.TagBrush)})},
args: ["aBlock"],
source: "onUnload: aBlock\x0a\x09self asJQuery bind: 'unload' do: aBlock",
messageSends: ["bind:do:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "placeholder:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("placeholder",aString);
return self}, function($ctx1) {$ctx1.fill(self,"placeholder:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "placeholder: aString\x0a\x09self at: 'placeholder' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "rel:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("rel",aString);
return self}, function($ctx1) {$ctx1.fill(self,"rel:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "rel: aString\x0a\x09self at: 'rel' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "removeAt:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self['@element'].removeAttribute(aString);
return self}, function($ctx1) {$ctx1.fill(self,"removeAt:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "removeAt: aString\x0a\x09<self['@element'].removeAttribute(aString)>",
messageSends: [],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "removeClass:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._element())._asJQuery())._removeClass_(aString);
return self}, function($ctx1) {$ctx1.fill(self,"removeClass:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "removeClass: aString\x0a\x09self element asJQuery removeClass: aString",
messageSends: ["removeClass:", "asJQuery", "element"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "resizable",
category: 'attributes',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._addClass_("resizable");
_st(_st(_st(self)._element())._asJQuery())._resizable();
return self}, function($ctx1) {$ctx1.fill(self,"resizable",{},smalltalk.TagBrush)})},
args: [],
source: "resizable\x0a\x09self addClass: 'resizable'.\x0a\x09self element asJQuery resizable.",
messageSends: ["addClass:", "resizable", "asJQuery", "element"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "rows:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("rows",aString);
return self}, function($ctx1) {$ctx1.fill(self,"rows:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "rows: aString\x0a\x09self at: 'rows' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "selectable",
category: 'attributes',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._addClass_("selectable");
return self}, function($ctx1) {$ctx1.fill(self,"selectable",{},smalltalk.TagBrush)})},
args: [],
source: "selectable\x0a\x09self addClass: 'selectable'.\x0a\x09\x22self element asJQuery selectable.\x22",
messageSends: ["addClass:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "src:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("src",aString);
return self}, function($ctx1) {$ctx1.fill(self,"src:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "src: aString\x0a\x09self at: 'src' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "style:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("style",aString);
return self}, function($ctx1) {$ctx1.fill(self,"style:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "style: aString\x0a\x09self at: 'style' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "tabindex:",
category: 'attributes',
fn: function (aNumber){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("tabindex",aNumber);
return self}, function($ctx1) {$ctx1.fill(self,"tabindex:",{aNumber:aNumber},smalltalk.TagBrush)})},
args: ["aNumber"],
source: "tabindex: aNumber\x0a\x09self at: 'tabindex' put: aNumber",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "target:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("target",aString);
return self}, function($ctx1) {$ctx1.fill(self,"target:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "target: aString\x0a\x09self at: 'target' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "title:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("title",aString);
return self}, function($ctx1) {$ctx1.fill(self,"title:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "title: aString\x0a\x09self at: 'title' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "trigger:",
category: 'events',
fn: function (anEventString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._asJQuery())._trigger_(anEventString);
return self}, function($ctx1) {$ctx1.fill(self,"trigger:",{anEventString:anEventString},smalltalk.TagBrush)})},
args: ["anEventString"],
source: "trigger: anEventString\x0a\x09self asJQuery trigger: anEventString",
messageSends: ["trigger:", "asJQuery"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "type:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("type",aString);
return self}, function($ctx1) {$ctx1.fill(self,"type:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "type: aString\x0a\x09self at: 'type' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "valign:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("valign",aString);
return self}, function($ctx1) {$ctx1.fill(self,"valign:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "valign: aString\x0a\x09self at: 'valign' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "value:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("value",aString);
return self}, function($ctx1) {$ctx1.fill(self,"value:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "value: aString\x0a\x09self at: 'value' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "width:",
category: 'attributes',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._at_put_("width",aString);
return self}, function($ctx1) {$ctx1.fill(self,"width:",{aString:aString},smalltalk.TagBrush)})},
args: ["aString"],
source: "width: aString\x0a\x09self at: 'width' put: aString",
messageSends: ["at:put:"],
referencedClasses: []
}),
smalltalk.TagBrush);

smalltalk.addMethod(
smalltalk.method({
selector: "with:",
category: 'adding',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._append_(anObject);
return self}, function($ctx1) {$ctx1.fill(self,"with:",{anObject:anObject},smalltalk.TagBrush)})},
args: ["anObject"],
source: "with: anObject\x0a\x09self append: anObject",
messageSends: ["append:"],
referencedClasses: []
}),
smalltalk.TagBrush);


smalltalk.addMethod(
smalltalk.method({
selector: "fromJQuery:canvas:",
category: 'instance creation',
fn: function (aJQuery,aCanvas){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._new();
_st($2)._initializeFromJQuery_canvas_(aJQuery,aCanvas);
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"fromJQuery:canvas:",{aJQuery:aJQuery,aCanvas:aCanvas},smalltalk.TagBrush.klass)})},
args: ["aJQuery", "aCanvas"],
source: "fromJQuery: aJQuery canvas: aCanvas\x0a\x09^self new\x0a\x09initializeFromJQuery: aJQuery canvas: aCanvas;\x0a\x09yourself",
messageSends: ["initializeFromJQuery:canvas:", "new", "yourself"],
referencedClasses: []
}),
smalltalk.TagBrush.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "fromString:canvas:",
category: 'instance creation',
fn: function (aString,aCanvas){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._new();
_st($2)._initializeFromString_canvas_(aString,aCanvas);
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"fromString:canvas:",{aString:aString,aCanvas:aCanvas},smalltalk.TagBrush.klass)})},
args: ["aString", "aCanvas"],
source: "fromString: aString canvas: aCanvas\x0a\x09^self new\x0a\x09initializeFromString: aString canvas: aCanvas;\x0a\x09yourself",
messageSends: ["initializeFromString:canvas:", "new", "yourself"],
referencedClasses: []
}),
smalltalk.TagBrush.klass);


smalltalk.addClass('StyleTag', smalltalk.TagBrush, ['canvas', 'element'], 'Canvas');
smalltalk.StyleTag.comment="I'm a <style> tag use to inline CSS or load a stylesheet.\x0a\x0aFor inlining handle IE compatibility problems."
smalltalk.addMethod(
smalltalk.method({
selector: "with:",
category: 'adding',
fn: function (aString){
var self=this;
function $HTMLCanvas(){return smalltalk.HTMLCanvas||(typeof HTMLCanvas=="undefined"?nil:HTMLCanvas)}
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st($HTMLCanvas())._isMSIE();
if(smalltalk.assert($1)){
_st(_st(_st(self)._element())._styleSheet())._cssText_(aString);
} else {
smalltalk.TagBrush.fn.prototype._with_.apply(_st(self), [aString]);
};
return self}, function($ctx1) {$ctx1.fill(self,"with:",{aString:aString},smalltalk.StyleTag)})},
args: ["aString"],
source: "with: aString\x0a\x09HTMLCanvas isMSIE\x0a\x09\x09ifTrue: [self element styleSheet cssText: aString ]\x0a\x09\x09ifFalse: [super with: aString ].",
messageSends: ["ifTrue:ifFalse:", "cssText:", "styleSheet", "element", "with:", "isMSIE"],
referencedClasses: ["HTMLCanvas"]
}),
smalltalk.StyleTag);


smalltalk.addMethod(
smalltalk.method({
selector: "canvas:",
category: 'instance creation',
fn: function (aCanvas){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._new();
_st($2)._initializeFromString_canvas_("style",aCanvas);
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"canvas:",{aCanvas:aCanvas},smalltalk.StyleTag.klass)})},
args: ["aCanvas"],
source: "canvas: aCanvas\x0a\x09^self new\x0a\x09initializeFromString: 'style' canvas: aCanvas;\x0a\x09yourself",
messageSends: ["initializeFromString:canvas:", "new", "yourself"],
referencedClasses: []
}),
smalltalk.StyleTag.klass);


smalltalk.addClass('TextMorphForEditView', smalltalk.Object, ['textMorph'], 'Canvas');


smalltalk.addClass('Widget', smalltalk.Object, [], 'Canvas');
smalltalk.addMethod(
smalltalk.method({
selector: "appendToBrush:",
category: 'adding',
fn: function (aTagBrush){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._appendToJQuery_(_st(aTagBrush)._asJQuery());
return self}, function($ctx1) {$ctx1.fill(self,"appendToBrush:",{aTagBrush:aTagBrush},smalltalk.Widget)})},
args: ["aTagBrush"],
source: "appendToBrush: aTagBrush\x0a\x09self appendToJQuery: aTagBrush asJQuery",
messageSends: ["appendToJQuery:", "asJQuery"],
referencedClasses: []
}),
smalltalk.Widget);

smalltalk.addMethod(
smalltalk.method({
selector: "appendToJQuery:",
category: 'adding',
fn: function (aJQuery){
var self=this;
function $HTMLCanvas(){return smalltalk.HTMLCanvas||(typeof HTMLCanvas=="undefined"?nil:HTMLCanvas)}
return smalltalk.withContext(function($ctx1) { 
_st(self)._renderOn_(_st($HTMLCanvas())._onJQuery_(aJQuery));
return self}, function($ctx1) {$ctx1.fill(self,"appendToJQuery:",{aJQuery:aJQuery},smalltalk.Widget)})},
args: ["aJQuery"],
source: "appendToJQuery: aJQuery\x0a\x09self renderOn: (HTMLCanvas onJQuery: aJQuery)",
messageSends: ["renderOn:", "onJQuery:"],
referencedClasses: ["HTMLCanvas"]
}),
smalltalk.Widget);

smalltalk.addMethod(
smalltalk.method({
selector: "renderOn:",
category: 'rendering',
fn: function (html){
var self=this;
return smalltalk.withContext(function($ctx1) { 
return self}, function($ctx1) {$ctx1.fill(self,"renderOn:",{html:html},smalltalk.Widget)})},
args: ["html"],
source: "renderOn: html\x0a\x09self",
messageSends: [],
referencedClasses: []
}),
smalltalk.Widget);



smalltalk.addClass('Morph', smalltalk.Widget, ['morphElement', 'submorphs', 'owner', 'adherentToEdge'], 'Canvas');
smalltalk.addMethod(
smalltalk.method({
selector: "addClass:",
category: 'css',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._addClass_(aString);
return self}, function($ctx1) {$ctx1.fill(self,"addClass:",{aString:aString},smalltalk.Morph)})},
args: ["aString"],
source: "addClass: aString\x0a\x09self morphElement asJQuery addClass: aString.",
messageSends: ["addClass:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "addMorph:",
category: 'submorphs',
fn: function (aMorph){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._submorphs())._add_(aMorph);
_st(aMorph)._owner_(self);
_st(aMorph)._moveToJQuery_(_st(_st(self)._submorphContainer())._asJQuery());
_st(aMorph)._ownerChanged();
return self}, function($ctx1) {$ctx1.fill(self,"addMorph:",{aMorph:aMorph},smalltalk.Morph)})},
args: ["aMorph"],
source: "addMorph: aMorph\x0a\x09self submorphs add: aMorph.\x0a\x09aMorph owner: self.\x0a\x09aMorph moveToJQuery: self submorphContainer asJQuery.\x0a\x09aMorph ownerChanged.",
messageSends: ["add:", "submorphs", "owner:", "moveToJQuery:", "asJQuery", "submorphContainer", "ownerChanged"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "adherentToEdge",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@adherentToEdge"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"adherentToEdge",{},smalltalk.Morph)})},
args: [],
source: "adherentToEdge\x0a\x09^ adherentToEdge",
messageSends: [],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "autoPosition",
category: 'private',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("left","auto");
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("right","auto");
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("top","auto");
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("bottom","auto");
return self}, function($ctx1) {$ctx1.fill(self,"autoPosition",{},smalltalk.Morph)})},
args: [],
source: "autoPosition\x0a\x09self morphElement asJQuery css: 'left' a: 'auto'.\x0a\x09self morphElement asJQuery css: 'right' a: 'auto'.\x0a\x09self morphElement asJQuery css: 'top' a: 'auto'.\x0a\x09self morphElement asJQuery css: 'bottom' a: 'auto'.",
messageSends: ["css:a:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "bindEvents",
category: 'events handling',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
return self}, function($ctx1) {$ctx1.fill(self,"bindEvents",{},smalltalk.Morph)})},
args: [],
source: "bindEvents",
messageSends: [],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "bottomCss:",
category: 'private',
fn: function (aNumber){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("bottom",_st(_st(aNumber)._asString()).__comma("px"));
return self}, function($ctx1) {$ctx1.fill(self,"bottomCss:",{aNumber:aNumber},smalltalk.Morph)})},
args: ["aNumber"],
source: "bottomCss: aNumber\x0a\x09self morphElement asJQuery css: 'bottom' a: aNumber asString, 'px'.",
messageSends: ["css:a:", ",", "asString", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "delete",
category: 'submorphs',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._owner())._isMorph();
if(smalltalk.assert($1)){
_st(_st(_st(self)._owner())._submorphs())._remove_(self);
_st(_st(_st(self)._morphElement())._asJQuery())._remove();
};
return self}, function($ctx1) {$ctx1.fill(self,"delete",{},smalltalk.Morph)})},
args: [],
source: "delete\x0a\x09self owner isMorph ifTrue: [\x0a\x09\x09self owner submorphs remove: self.\x0a\x09\x09self morphElement asJQuery remove].",
messageSends: ["ifTrue:", "remove:", "submorphs", "owner", "remove", "asJQuery", "morphElement", "isMorph"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "extent:",
category: 'geometry',
fn: function (aPoint){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._width_(_st(aPoint)._x());
_st(self)._height_(_st(aPoint)._y());
return self}, function($ctx1) {$ctx1.fill(self,"extent:",{aPoint:aPoint},smalltalk.Morph)})},
args: ["aPoint"],
source: "extent: aPoint\x0a\x09self width: aPoint x.\x0a\x09self height: aPoint y.",
messageSends: ["width:", "x", "height:", "y"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "height",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(_st(self)._morphElement())._asJQuery())._css_("height"))._parseFloat();
return $1;
}, function($ctx1) {$ctx1.fill(self,"height",{},smalltalk.Morph)})},
args: [],
source: "height\x0a\x09^ (self morphElement asJQuery css: 'height') parseFloat",
messageSends: ["parseFloat", "css:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "height:",
category: 'geometry',
fn: function (aNumber){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("height",_st(_st(aNumber)._asString()).__comma("px"));
return self}, function($ctx1) {$ctx1.fill(self,"height:",{aNumber:aNumber},smalltalk.Morph)})},
args: ["aNumber"],
source: "height: aNumber\x0a\x09self morphElement asJQuery css: 'height' a: aNumber asString, 'px'.",
messageSends: ["css:a:", ",", "asString", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "heightPercent:",
category: 'geometry',
fn: function (aNumber){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("height",_st(_st(aNumber)._asString()).__comma("%"));
return self}, function($ctx1) {$ctx1.fill(self,"heightPercent:",{aNumber:aNumber},smalltalk.Morph)})},
args: ["aNumber"],
source: "heightPercent: aNumber\x0a\x09self morphElement asJQuery css: 'height' a: aNumber asString, '%'.",
messageSends: ["css:a:", ",", "asString", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "initialize",
category: 'initializing',
fn: function (){
var self=this;
function $OrderedCollection(){return smalltalk.OrderedCollection||(typeof OrderedCollection=="undefined"?nil:OrderedCollection)}
return smalltalk.withContext(function($ctx1) { 
smalltalk.Widget.fn.prototype._initialize.apply(_st(self), []);
self["@adherentToEdge"]="none";
self["@submorphs"]=_st($OrderedCollection())._new();
_st(self)._appendToJQuery_(_st(self)._temporaryRenderContainer());
return self}, function($ctx1) {$ctx1.fill(self,"initialize",{},smalltalk.Morph)})},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09adherentToEdge := #none.\x0a\x09submorphs := OrderedCollection new.\x0a\x09self appendToJQuery: self temporaryRenderContainer.",
messageSends: ["initialize", "new", "appendToJQuery:", "temporaryRenderContainer"],
referencedClasses: ["OrderedCollection"]
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "isMorph",
category: 'testing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
return true;
}, function($ctx1) {$ctx1.fill(self,"isMorph",{},smalltalk.Morph)})},
args: [],
source: "isMorph\x0a\x09^ true",
messageSends: [],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "left",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(_st(self)._morphElement())._asJQuery())._css_("left"))._parseFloat();
return $1;
}, function($ctx1) {$ctx1.fill(self,"left",{},smalltalk.Morph)})},
args: [],
source: "left\x0a\x09^ (self morphElement asJQuery css: 'left') parseFloat",
messageSends: ["parseFloat", "css:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "left:",
category: 'geometry',
fn: function (aNumber){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("left",_st(_st(aNumber)._asString()).__comma("px"));
return self}, function($ctx1) {$ctx1.fill(self,"left:",{aNumber:aNumber},smalltalk.Morph)})},
args: ["aNumber"],
source: "left: aNumber\x0a\x09self morphElement asJQuery css: 'left' a: aNumber asString, 'px'.",
messageSends: ["css:a:", ",", "asString", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "margin",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(_st(self)._morphElement())._asJQuery())._css_("margin"))._parseFloat();
return $1;
}, function($ctx1) {$ctx1.fill(self,"margin",{},smalltalk.Morph)})},
args: [],
source: "margin\x0a\x09^ (self morphElement asJQuery css: 'margin') parseFloat",
messageSends: ["parseFloat", "css:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "margin:",
category: 'geometry',
fn: function (aNumber){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("margin",_st(_st(aNumber)._asString()).__comma("px"));
return self}, function($ctx1) {$ctx1.fill(self,"margin:",{aNumber:aNumber},smalltalk.Morph)})},
args: ["aNumber"],
source: "margin: aNumber\x0a\x09self morphElement asJQuery css: 'margin' a: aNumber asString, 'px'.",
messageSends: ["css:a:", ",", "asString", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "morphElement",
category: 'private',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@morphElement"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"morphElement",{},smalltalk.Morph)})},
args: [],
source: "morphElement\x0a\x09^ morphElement",
messageSends: [],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "moveToJQuery:",
category: 'private',
fn: function (aJQuery){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(aJQuery)._append_(_st(_st(self)._morphElement())._asJQuery());
return self}, function($ctx1) {$ctx1.fill(self,"moveToJQuery:",{aJQuery:aJQuery},smalltalk.Morph)})},
args: ["aJQuery"],
source: "moveToJQuery: aJQuery\x0a\x09aJQuery append: self morphElement asJQuery.",
messageSends: ["append:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "overflow",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(self)._morphElement())._asJQuery())._css_("overflow");
return $1;
}, function($ctx1) {$ctx1.fill(self,"overflow",{},smalltalk.Morph)})},
args: [],
source: "overflow\x0a\x09^ self morphElement asJQuery css: 'overflow'",
messageSends: ["css:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "overflow:",
category: 'geometry',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("overflow",aString);
return self}, function($ctx1) {$ctx1.fill(self,"overflow:",{aString:aString},smalltalk.Morph)})},
args: ["aString"],
source: "overflow: aString\x0a\x09self morphElement asJQuery css: 'overflow' a: aString",
messageSends: ["css:a:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "overflowX",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(self)._morphElement())._asJQuery())._css_("overflow-x");
return $1;
}, function($ctx1) {$ctx1.fill(self,"overflowX",{},smalltalk.Morph)})},
args: [],
source: "overflowX\x0a\x09^ self morphElement asJQuery css: 'overflow-x'",
messageSends: ["css:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "overflowX:",
category: 'geometry',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("overflow-x",aString);
return self}, function($ctx1) {$ctx1.fill(self,"overflowX:",{aString:aString},smalltalk.Morph)})},
args: ["aString"],
source: "overflowX: aString\x0a\x09self morphElement asJQuery css: 'overflow-x' a: aString",
messageSends: ["css:a:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "overflowY",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(self)._morphElement())._asJQuery())._css_("overflow-y");
return $1;
}, function($ctx1) {$ctx1.fill(self,"overflowY",{},smalltalk.Morph)})},
args: [],
source: "overflowY\x0a\x09^ self morphElement asJQuery css: 'overflow-y'",
messageSends: ["css:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "overflowY:",
category: 'geometry',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("overflow-y",aString);
return self}, function($ctx1) {$ctx1.fill(self,"overflowY:",{aString:aString},smalltalk.Morph)})},
args: ["aString"],
source: "overflowY: aString\x0a\x09self morphElement asJQuery css: 'overflow-y' a: aString",
messageSends: ["css:a:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "owner",
category: 'submorphs',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@owner"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"owner",{},smalltalk.Morph)})},
args: [],
source: "owner\x0a\x09^ owner",
messageSends: [],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "owner:",
category: 'private',
fn: function (aMorph){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@owner"]=aMorph;
return self}, function($ctx1) {$ctx1.fill(self,"owner:",{aMorph:aMorph},smalltalk.Morph)})},
args: ["aMorph"],
source: "owner: aMorph\x0a\x09owner := aMorph.",
messageSends: [],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "ownerChanged",
category: 'submorphs',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._updateLayout();
return self}, function($ctx1) {$ctx1.fill(self,"ownerChanged",{},smalltalk.Morph)})},
args: [],
source: "ownerChanged\x0a\x09self updateLayout.",
messageSends: ["updateLayout"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "ownerPadding",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2,$3;
$1=_st(_st(self)._owner())._isMorph();
if(smalltalk.assert($1)){
$2=_st(_st(self)._owner())._padding();
return $2;
} else {
$3=(0);
return $3;
};
return self}, function($ctx1) {$ctx1.fill(self,"ownerPadding",{},smalltalk.Morph)})},
args: [],
source: "ownerPadding\x0a\x09self owner isMorph\x0a\x09\x09ifTrue: [^ self owner padding]\x0a\x09\x09ifFalse: [ ^ 0].",
messageSends: ["ifTrue:ifFalse:", "padding", "owner", "isMorph"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "padding",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(_st(self)._morphElement())._asJQuery())._css_("padding"))._parseFloat();
return $1;
}, function($ctx1) {$ctx1.fill(self,"padding",{},smalltalk.Morph)})},
args: [],
source: "padding\x0a\x09^ (self morphElement asJQuery css: 'padding') parseFloat",
messageSends: ["parseFloat", "css:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "padding:",
category: 'geometry',
fn: function (aNumber){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("padding",_st(_st(aNumber)._asString()).__comma("px"));
return self}, function($ctx1) {$ctx1.fill(self,"padding:",{aNumber:aNumber},smalltalk.Morph)})},
args: ["aNumber"],
source: "padding: aNumber\x0a\x09self morphElement asJQuery css: 'padding' a: aNumber asString, 'px'.",
messageSends: ["css:a:", ",", "asString", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "paddingLeft",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(_st(self)._morphElement())._asJQuery())._css_("padding-left"))._parseFloat();
return $1;
}, function($ctx1) {$ctx1.fill(self,"paddingLeft",{},smalltalk.Morph)})},
args: [],
source: "paddingLeft\x0a\x09^ (self morphElement asJQuery css: 'padding-left') parseFloat",
messageSends: ["parseFloat", "css:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "paddingLeft:",
category: 'geometry',
fn: function (aNumber){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("padding-left",_st(_st(aNumber)._asString()).__comma("px"));
return self}, function($ctx1) {$ctx1.fill(self,"paddingLeft:",{aNumber:aNumber},smalltalk.Morph)})},
args: ["aNumber"],
source: "paddingLeft: aNumber\x0a\x09self morphElement asJQuery css: 'padding-left' a: aNumber asString, 'px'.",
messageSends: ["css:a:", ",", "asString", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "paddingTop",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(_st(self)._morphElement())._asJQuery())._css_("padding-top"))._parseFloat();
return $1;
}, function($ctx1) {$ctx1.fill(self,"paddingTop",{},smalltalk.Morph)})},
args: [],
source: "paddingTop\x0a\x09^ (self morphElement asJQuery css: 'padding-top') parseFloat",
messageSends: ["parseFloat", "css:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "paddingTop:",
category: 'geometry',
fn: function (aNumber){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("padding-top",_st(_st(aNumber)._asString()).__comma("px"));
return self}, function($ctx1) {$ctx1.fill(self,"paddingTop:",{aNumber:aNumber},smalltalk.Morph)})},
args: ["aNumber"],
source: "paddingTop: aNumber\x0a\x09self morphElement asJQuery css: 'padding-top' a: aNumber asString, 'px'.",
messageSends: ["css:a:", ",", "asString", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "position:",
category: 'geometry',
fn: function (aPoint){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._left_(_st(aPoint)._x());
_st(self)._top_(_st(aPoint)._y());
return self}, function($ctx1) {$ctx1.fill(self,"position:",{aPoint:aPoint},smalltalk.Morph)})},
args: ["aPoint"],
source: "position: aPoint\x0a\x09self left: aPoint x.\x0a\x09self top: aPoint y.",
messageSends: ["left:", "x", "top:", "y"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "positionAbsolute",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("position","absolute");
return self}, function($ctx1) {$ctx1.fill(self,"positionAbsolute",{},smalltalk.Morph)})},
args: [],
source: "positionAbsolute\x0a\x09self morphElement asJQuery css: 'position' a: 'absolute'.",
messageSends: ["css:a:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "positionRelative",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("position","relative");
return self}, function($ctx1) {$ctx1.fill(self,"positionRelative",{},smalltalk.Morph)})},
args: [],
source: "positionRelative\x0a\x09self morphElement asJQuery css: 'position' a: 'relative'.",
messageSends: ["css:a:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "removeAllSubmorphs",
category: 'submorphs',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._submorphs())._do_((function(m){
return smalltalk.withContext(function($ctx2) {
return _st(m)._delete();
}, function($ctx2) {$ctx2.fillBlock({m:m},$ctx1)})}));
_st(self)._updateLayout();
return self}, function($ctx1) {$ctx1.fill(self,"removeAllSubmorphs",{},smalltalk.Morph)})},
args: [],
source: "removeAllSubmorphs\x0a\x09self submorphs do: [:m| m delete].\x0a\x09self updateLayout",
messageSends: ["do:", "delete", "submorphs", "updateLayout"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "removeClass:",
category: 'css',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._removeClass_(aString);
return self}, function($ctx1) {$ctx1.fill(self,"removeClass:",{aString:aString},smalltalk.Morph)})},
args: ["aString"],
source: "removeClass: aString\x0a\x09self morphElement asJQuery removeClass: aString.",
messageSends: ["removeClass:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "render:with:",
category: 'rendering',
fn: function (container,html){
var self=this;
return smalltalk.withContext(function($ctx1) { 
return self}, function($ctx1) {$ctx1.fill(self,"render:with:",{container:container,html:html},smalltalk.Morph)})},
args: ["container", "html"],
source: "render: container with: html",
messageSends: [],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "renderOn:",
category: 'rendering',
fn: function (html){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@morphElement"]=_st(html)._div();
_st(self)._render_with_(self["@morphElement"],html);
_st(self)._bindEvents();
return self}, function($ctx1) {$ctx1.fill(self,"renderOn:",{html:html},smalltalk.Morph)})},
args: ["html"],
source: "renderOn: html\x0a\x09morphElement := html div.\x0a\x09self render: morphElement with: html.\x0a\x09self bindEvents.",
messageSends: ["div", "render:with:", "bindEvents"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "rightCss:",
category: 'private',
fn: function (aNumber){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("right",_st(_st(aNumber)._asString()).__comma("px"));
return self}, function($ctx1) {$ctx1.fill(self,"rightCss:",{aNumber:aNumber},smalltalk.Morph)})},
args: ["aNumber"],
source: "rightCss: aNumber\x0a\x09self morphElement asJQuery css: 'right' a: aNumber asString, 'px'.",
messageSends: ["css:a:", ",", "asString", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "setToAdhereToEdge:",
category: 'geometry',
fn: function (anEdge){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2,$3,$4;
_st(self)._autoPosition();
_st(self)._positionAbsolute();
self["@adherentToEdge"]=anEdge;
$1=_st(anEdge).__eq("top");
if(smalltalk.assert($1)){
_st(self)._top_(_st(self)._ownerPadding());
};
$2=_st(anEdge).__eq("left");
if(smalltalk.assert($2)){
_st(self)._left_(_st(self)._ownerPadding());
};
$3=_st(anEdge).__eq("bottom");
if(smalltalk.assert($3)){
_st(self)._bottomCss_(_st(self)._ownerPadding());
};
$4=_st(anEdge).__eq("right");
if(smalltalk.assert($4)){
_st(self)._rightCss_(_st(self)._ownerPadding());
};
return self}, function($ctx1) {$ctx1.fill(self,"setToAdhereToEdge:",{anEdge:anEdge},smalltalk.Morph)})},
args: ["anEdge"],
source: "setToAdhereToEdge: anEdge\x0a\x09self autoPosition.\x0a\x09self positionAbsolute.\x0a\x09adherentToEdge := anEdge.\x0a\x09anEdge = #top ifTrue: [self top: self ownerPadding].\x0a\x09anEdge = #left ifTrue: [self left: self ownerPadding].\x0a\x09anEdge = #bottom ifTrue: [self bottomCss: self ownerPadding].\x0a\x09anEdge = #right ifTrue: [self rightCss: self ownerPadding].",
messageSends: ["autoPosition", "positionAbsolute", "ifTrue:", "top:", "ownerPadding", "=", "left:", "bottomCss:", "rightCss:"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "submorphContainer",
category: 'submorphs',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._morphElement();
return $1;
}, function($ctx1) {$ctx1.fill(self,"submorphContainer",{},smalltalk.Morph)})},
args: [],
source: "submorphContainer\x0a\x09^ self morphElement",
messageSends: ["morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "submorphs",
category: 'submorphs',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@submorphs"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"submorphs",{},smalltalk.Morph)})},
args: [],
source: "submorphs\x0a\x09^ submorphs",
messageSends: [],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "submorphsDo:",
category: 'submorphs',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._submorphs())._do_(aBlock);
return self}, function($ctx1) {$ctx1.fill(self,"submorphsDo:",{aBlock:aBlock},smalltalk.Morph)})},
args: ["aBlock"],
source: "submorphsDo: aBlock\x0a\x09self submorphs do: aBlock.",
messageSends: ["do:", "submorphs"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "temporaryRenderContainer",
category: 'private',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st("#temp-render")._asJQuery();
return $1;
}, function($ctx1) {$ctx1.fill(self,"temporaryRenderContainer",{},smalltalk.Morph)})},
args: [],
source: "temporaryRenderContainer\x0a\x09^ '#temp-render' asJQuery",
messageSends: ["asJQuery"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "top",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(_st(self)._morphElement())._asJQuery())._css_("top"))._parseFloat();
return $1;
}, function($ctx1) {$ctx1.fill(self,"top",{},smalltalk.Morph)})},
args: [],
source: "top\x0a\x09^ (self morphElement asJQuery css: 'top') parseFloat",
messageSends: ["parseFloat", "css:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "top:",
category: 'geometry',
fn: function (aNumber){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("top",_st(_st(aNumber)._asString()).__comma("px"));
return self}, function($ctx1) {$ctx1.fill(self,"top:",{aNumber:aNumber},smalltalk.Morph)})},
args: ["aNumber"],
source: "top: aNumber\x0a\x09self morphElement asJQuery css: 'top' a: aNumber asString, 'px'.",
messageSends: ["css:a:", ",", "asString", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "updateLayout",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._adherentToEdge()).__tild_tild("none");
if(smalltalk.assert($1)){
_st(self)._setToAdhereToEdge_(_st(self)._adherentToEdge());
};
_st(self)._submorphsDo_((function(morph){
return smalltalk.withContext(function($ctx2) {
return _st(morph)._updateLayout();
}, function($ctx2) {$ctx2.fillBlock({morph:morph},$ctx1)})}));
return self}, function($ctx1) {$ctx1.fill(self,"updateLayout",{},smalltalk.Morph)})},
args: [],
source: "updateLayout\x0a\x09self adherentToEdge ~~ #none \x0a\x09\x09ifTrue: [self setToAdhereToEdge: self adherentToEdge].\x0a\x09self submorphsDo: [:morph | morph updateLayout].",
messageSends: ["ifTrue:", "setToAdhereToEdge:", "adherentToEdge", "~~", "submorphsDo:", "updateLayout"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "width",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(_st(self)._morphElement())._asJQuery())._css_("width"))._parseFloat();
return $1;
}, function($ctx1) {$ctx1.fill(self,"width",{},smalltalk.Morph)})},
args: [],
source: "width\x0a\x09^ (self morphElement asJQuery css: 'width') parseFloat",
messageSends: ["parseFloat", "css:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "width:",
category: 'geometry',
fn: function (aNumber){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("width",_st(_st(aNumber)._asString()).__comma("px"));
return self}, function($ctx1) {$ctx1.fill(self,"width:",{aNumber:aNumber},smalltalk.Morph)})},
args: ["aNumber"],
source: "width: aNumber\x0a\x09self morphElement asJQuery css: 'width' a: aNumber asString, 'px'.",
messageSends: ["css:a:", ",", "asString", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "widthPercent:",
category: 'geometry',
fn: function (aNumber){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("width",_st(_st(aNumber)._asString()).__comma("%"));
return self}, function($ctx1) {$ctx1.fill(self,"widthPercent:",{aNumber:aNumber},smalltalk.Morph)})},
args: ["aNumber"],
source: "widthPercent: aNumber\x0a\x09self morphElement asJQuery css: 'width' a: aNumber asString, '%'.",
messageSends: ["css:a:", ",", "asString", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "windowPadding",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2,$3,$4,$5;
$1=_st(self)._isSystemWindow();
if(smalltalk.assert($1)){
$2=_st(self)._padding();
return $2;
} else {
$3=_st(_st(_st(self)._owner()).__tild_tild(nil))._and_((function(){
return smalltalk.withContext(function($ctx2) {
return _st(_st(self)._owner())._isMorph();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
if(smalltalk.assert($3)){
$4=_st(_st(self)._owner())._windowPadding();
return $4;
} else {
$5=(0);
return $5;
};
};
return self}, function($ctx1) {$ctx1.fill(self,"windowPadding",{},smalltalk.Morph)})},
args: [],
source: "windowPadding\x0a\x09self isSystemWindow\x0a\x09\x09ifTrue: [^ self padding]\x0a\x09\x09ifFalse: [\x0a\x09\x09\x09(self owner ~~ nil and: [self owner isMorph])\x0a\x09\x09\x09\x09ifTrue: [^ self owner windowPadding]\x0a\x09\x09\x09\x09ifFalse: [^ 0]].",
messageSends: ["ifTrue:ifFalse:", "padding", "windowPadding", "owner", "and:", "isMorph", "~~", "isSystemWindow"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "zIndex",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(_st(self)._morphElement())._asJQuery())._css_("zIndex"))._asNumber();
return $1;
}, function($ctx1) {$ctx1.fill(self,"zIndex",{},smalltalk.Morph)})},
args: [],
source: "zIndex\x0a\x09^ (self morphElement asJQuery css: 'zIndex') asNumber",
messageSends: ["asNumber", "css:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);

smalltalk.addMethod(
smalltalk.method({
selector: "zIndex:",
category: 'geometry',
fn: function (aNumber){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._morphElement())._asJQuery())._css_a_("zIndex",aNumber);
return self}, function($ctx1) {$ctx1.fill(self,"zIndex:",{aNumber:aNumber},smalltalk.Morph)})},
args: ["aNumber"],
source: "zIndex: aNumber\x0a\x09self morphElement asJQuery css: 'zIndex' a: aNumber",
messageSends: ["css:a:", "asJQuery", "morphElement"],
referencedClasses: []
}),
smalltalk.Morph);



smalltalk.addClass('BorderedMorph', smalltalk.Morph, ['morphElement', 'borderWidth'], 'Canvas');


smalltalk.addClass('PluggableListMorph', smalltalk.BorderedMorph, ['morphElement', 'list', 'listElement', 'getListSelector', 'getListElementSelector', 'getIndexSelector', 'setIndexSelector', 'model', 'listMorph', 'keyStrokeSelector', 'listEntries', 'listIndex', 'xhtml', 'scroll'], 'Canvas');
smalltalk.PluggableListMorph.comment="Instance Variables:\x0a\x09list\x09\x09\x09\x09holds the list that was retrieved by the model\x0a\x09listElement\x09\x09the ul dom element of the list\x0a\x09model\x09\x09\x09 e.g.: List is retreived from here"
smalltalk.addMethod(
smalltalk.method({
selector: "clearEntries",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._listEntries())._do_((function(each){
return smalltalk.withContext(function($ctx2) {
return _st(each)._remove();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1)})}));
return self}, function($ctx1) {$ctx1.fill(self,"clearEntries",{},smalltalk.PluggableListMorph)})},
args: [],
source: "clearEntries\x0a\x09self listEntries do:[:each| each remove]",
messageSends: ["do:", "remove", "listEntries"],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "getIndexSelector",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@getIndexSelector"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"getIndexSelector",{},smalltalk.PluggableListMorph)})},
args: [],
source: "getIndexSelector\x0a\x09^getIndexSelector",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "getIndexSelector:",
category: 'not yet classified',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@getIndexSelector"]=anObject;
return self}, function($ctx1) {$ctx1.fill(self,"getIndexSelector:",{anObject:anObject},smalltalk.PluggableListMorph)})},
args: ["anObject"],
source: "getIndexSelector: anObject\x0a\x09getIndexSelector:= anObject",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "getList",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2,$3,$4,$5;
$1=_st(self["@getListSelector"]).__eq_eq(nil);
if(smalltalk.assert($1)){
$2=[];
return $2;
};
self["@list"]=_st(self["@model"])._perform_(self["@getListSelector"]);
$3=_st(self["@list"]).__eq_eq(nil);
if(smalltalk.assert($3)){
$4=[];
return $4;
};
self["@list"]=_st(self["@list"])._collect_((function(each){
return smalltalk.withContext(function($ctx2) {
return _st(each)._asString();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1)})}));
$5=self["@list"];
return $5;
}, function($ctx1) {$ctx1.fill(self,"getList",{},smalltalk.PluggableListMorph)})},
args: [],
source: "getList\x0a\x09\x22Answer the list to be displayed.  Caches the returned list in the 'list' ivar\x22\x0a\x09getListSelector == nil ifTrue: [^ #()].\x0a\x09list := model perform: getListSelector.\x0a\x09list == nil ifTrue: [^ #()].\x0a\x09list := list collect: [:each| each asString].\x0a\x09^ list",
messageSends: ["ifTrue:", "==", "perform:", "collect:", "asString"],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "getListItem:",
category: 'not yet classified',
fn: function (index){
var self=this;
var element;
return smalltalk.withContext(function($ctx1) { 
var $1,$2,$3,$4,$5;
$1=self["@getListElementSelector"];
if(($receiver = $1) == nil || $receiver == undefined){
$1;
} else {
$2=_st(_st(_st(self)._model())._perform_with_(self["@getListElementSelector"],index))._asString();
return $2;
};
$3=self["@list"];
if(($receiver = $3) == nil || $receiver == undefined){
$3;
} else {
$4=_st(self["@list"])._at_(index);
return $4;
};
element=_st(_st(self)._getList())._at_(index);
$5=_st(_st(self)._element())._asString();
return $5;
}, function($ctx1) {$ctx1.fill(self,"getListItem:",{index:index,element:element},smalltalk.PluggableListMorph)})},
args: ["index"],
source: "getListItem: index\x0a\x09\x22get the index-th item in the displayed list\x22\x0a\x09| element |\x0a\x09getListElementSelector ifNotNil: [ ^ (self model perform: getListElementSelector with: index) asString].\x0a\x09list ifNotNil: [ ^ list at: index ].\x0a\x09\x0a\x09element := self getList at: index.\x0a\x09^ self element asString",
messageSends: ["ifNotNil:", "asString", "perform:with:", "model", "at:", "getList", "element"],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "getListSelector",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@getListSelector"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"getListSelector",{},smalltalk.PluggableListMorph)})},
args: [],
source: "getListSelector\x0a\x09^ getListSelector",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "getListSelector:",
category: 'not yet classified',
fn: function (sel){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@getListSelector"]=sel;
_st(self)._updateList();
return self}, function($ctx1) {$ctx1.fill(self,"getListSelector:",{sel:sel},smalltalk.PluggableListMorph)})},
args: ["sel"],
source: "getListSelector: sel\x0a\x09\x22Set the receiver's getListSelector as indicated, and trigger a recomputation of the list\x22\x0a\x0a\x09getListSelector := sel.\x0a\x09self updateList.",
messageSends: ["updateList"],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "getListSize",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._getList())._size();
return $1;
}, function($ctx1) {$ctx1.fill(self,"getListSize",{},smalltalk.PluggableListMorph)})},
args: [],
source: "getListSize\x0a\x09\x22return the current number of items in the displayed list\x22\x0a\x09^self getList size",
messageSends: ["size", "getList"],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "initialize",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._listEntries_([]);
self["@scroll"]=(0);
smalltalk.BorderedMorph.fn.prototype._initialize.apply(_st(self), []);
return self}, function($ctx1) {$ctx1.fill(self,"initialize",{},smalltalk.PluggableListMorph)})},
args: [],
source: "initialize\x0a\x09self listEntries: #().\x0a\x09scroll := 0.\x0a\x09super initialize",
messageSends: ["listEntries:", "initialize"],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "list",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@list"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"list",{},smalltalk.PluggableListMorph)})},
args: [],
source: "list\x0a\x09^list",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "list:",
category: 'not yet classified',
fn: function (anArray){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@list"]=anArray;
return self}, function($ctx1) {$ctx1.fill(self,"list:",{anArray:anArray},smalltalk.PluggableListMorph)})},
args: ["anArray"],
source: "list: anArray\x0a\x09list := anArray",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "listElement",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@listElement"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"listElement",{},smalltalk.PluggableListMorph)})},
args: [],
source: "listElement\x0a\x09^listElement",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "listElement:",
category: 'not yet classified',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@listElement"]=anObject;
return self}, function($ctx1) {$ctx1.fill(self,"listElement:",{anObject:anObject},smalltalk.PluggableListMorph)})},
args: ["anObject"],
source: "listElement: anObject\x0a\x09listElement := anObject",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "listEntries",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@listEntries"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"listEntries",{},smalltalk.PluggableListMorph)})},
args: [],
source: "listEntries\x0a\x09^listEntries",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "listEntries:",
category: 'not yet classified',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@listEntries"]=anObject;
return self}, function($ctx1) {$ctx1.fill(self,"listEntries:",{anObject:anObject},smalltalk.PluggableListMorph)})},
args: ["anObject"],
source: "listEntries: anObject\x0a\x09listEntries := anObject",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "listIndex",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
$1=self["@listIndex"];
if(($receiver = $1) == nil || $receiver == undefined){
self["@listIndex"]=(0);
self["@listIndex"];
} else {
$1;
};
$2=self["@listIndex"];
return $2;
}, function($ctx1) {$ctx1.fill(self,"listIndex",{},smalltalk.PluggableListMorph)})},
args: [],
source: "listIndex\x0a\x09listIndex ifNil: [listIndex := 0].\x0a\x09^listIndex",
messageSends: ["ifNil:"],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "listIndex:",
category: 'not yet classified',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(anObject)._isNumber();
if(! smalltalk.assert($1)){
_st(self)._error_("List index must be numerical");
};
self["@listIndex"]=anObject;
return self}, function($ctx1) {$ctx1.fill(self,"listIndex:",{anObject:anObject},smalltalk.PluggableListMorph)})},
args: ["anObject"],
source: "listIndex: anObject\x0a\x09anObject isNumber ifFalse: [self error: 'List index must be numerical'].\x0a\x09listIndex := anObject",
messageSends: ["ifFalse:", "error:", "isNumber"],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "model",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@model"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"model",{},smalltalk.PluggableListMorph)})},
args: [],
source: "model\x0a\x09^ model",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "model:",
category: 'not yet classified',
fn: function (aModel){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@model"]=aModel;
return self}, function($ctx1) {$ctx1.fill(self,"model:",{aModel:aModel},smalltalk.PluggableListMorph)})},
args: ["aModel"],
source: "model: aModel\x0a\x09model := aModel",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "moveSelectionDown",
category: 'not yet classified',
fn: function (){
var self=this;
var index,element;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
index=_st(_st(self)._model())._perform_(_st(self)._getIndexSelector());
$1=_st(index).__eq(_st(self)._getListSize());
if(! smalltalk.assert($1)){
index=_st(index).__plus((1));
index;
};
element=_st(_st(self)._listEntries())._at_(index);
_st(_st(element)._entry())._trigger_("click");
$2=_st(self)._outOfView_(element);
if(smalltalk.assert($2)){
self["@scroll"]=_st(_st(self)._getListSize())._min_(_st(self["@scroll"]).__plus((1)));
self["@scroll"];
_st(_st(_st(_st(_st(self)._listElement())._asJQuery())._find_("li.selectee"))._at_(self["@scroll"]))._scrollIntoView();
};
return self}, function($ctx1) {$ctx1.fill(self,"moveSelectionDown",{index:index,element:element},smalltalk.PluggableListMorph)})},
args: [],
source: "moveSelectionDown\x0a\x09|index element |\x0a\x09index := self model perform: self getIndexSelector.\x0a\x09index = self getListSize ifFalse: [ index := index +1].\x0a\x09element := self listEntries at: index.\x0a\x09element entry trigger: 'click'.\x0a\x09(self outOfView: element) ifTrue:[ scroll := self getListSize min: scroll +1.\x0a\x09((self listElement asJQuery find: 'li.selectee')at: scroll) scrollIntoView]",
messageSends: ["perform:", "getIndexSelector", "model", "ifFalse:", "+", "=", "getListSize", "at:", "listEntries", "trigger:", "entry", "ifTrue:", "min:", "scrollIntoView", "find:", "asJQuery", "listElement", "outOfView:"],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "moveSelectionUp",
category: 'not yet classified',
fn: function (){
var self=this;
var index,element;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
index=_st(_st(self)._model())._perform_(_st(self)._getIndexSelector());
$1=_st(index).__eq((1));
if(! smalltalk.assert($1)){
index=_st(index).__minus((1));
index;
};
element=_st(_st(self)._listEntries())._at_(index);
_st(_st(element)._entry())._trigger_("click");
$2=_st(self)._outOfView_(element);
if(smalltalk.assert($2)){
self["@scroll"]=_st((0))._max_(_st(self["@scroll"]).__minus((1)));
self["@scroll"];
_st(_st(_st(_st(_st(self)._listElement())._asJQuery())._find_("li.selectee"))._at_(self["@scroll"]))._scrollIntoView();
};
return self}, function($ctx1) {$ctx1.fill(self,"moveSelectionUp",{index:index,element:element},smalltalk.PluggableListMorph)})},
args: [],
source: "moveSelectionUp\x0a\x09|index element|\x0a\x09index := self model perform: self getIndexSelector.\x0a\x09index = 1 ifFalse: [ index := index - 1].\x0a\x09element := self listEntries at: index.\x0a\x09element entry trigger: 'click'.\x0a\x09(self outOfView: element) ifTrue:[  scroll := 0 max: scroll -1.\x0a\x09((self listElement asJQuery find: 'li.selectee')at: scroll) scrollIntoView]",
messageSends: ["perform:", "getIndexSelector", "model", "ifFalse:", "-", "=", "at:", "listEntries", "trigger:", "entry", "ifTrue:", "max:", "scrollIntoView", "find:", "asJQuery", "listElement", "outOfView:"],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "on:list:selected:changeSelected:",
category: 'not yet classified',
fn: function (anObject,getListSel,getSelectionSel,setSelectionSel){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._model_(anObject);
self["@getListSelector"]=getListSel;
self["@getIndexSelector"]=getSelectionSel;
self["@setIndexSelector"]=setSelectionSel;
_st(self)._updateList();
return self}, function($ctx1) {$ctx1.fill(self,"on:list:selected:changeSelected:",{anObject:anObject,getListSel:getListSel,getSelectionSel:getSelectionSel,setSelectionSel:setSelectionSel},smalltalk.PluggableListMorph)})},
args: ["anObject", "getListSel", "getSelectionSel", "setSelectionSel"],
source: "on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel\x0a\x09self model: anObject.\x0a\x09getListSelector := getListSel.\x0a\x09getIndexSelector := getSelectionSel.\x0a\x09setIndexSelector := setSelectionSel.\x0a\x09self updateList",
messageSends: ["model:", "updateList"],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "outOfView:",
category: 'not yet classified',
fn: function (element){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(_st(_st(_st(_st(element)._entry())._asJQuery())._position())._top()).__plus(_st(_st(_st(element)._entry())._asJQuery())._height())).__gt(_st(_st(_st(self)._morphElement())._asJQuery())._height()))._or_((function(){
return smalltalk.withContext(function($ctx2) {
return _st(_st(_st(_st(_st(element)._entry())._asJQuery())._position())._top()).__lt((0));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
return $1;
}, function($ctx1) {$ctx1.fill(self,"outOfView:",{element:element},smalltalk.PluggableListMorph)})},
args: ["element"],
source: "outOfView: element\x0a\x09\x09^(element entry asJQuery position top + element entry asJQuery height) > self morphElement asJQuery height \x0a\x09\x09\x09or: [element entry asJQuery position top  < 0]",
messageSends: ["or:", "<", "top", "position", "asJQuery", "entry", ">", "height", "morphElement", "+"],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "render:with:",
category: 'not yet classified',
fn: function (container,html){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$3,$4,$2;
self["@xhtml"]=html;
$1=container;
_st($1)._class_("drag-stop");
$2=_st($1)._with_((function(){
return smalltalk.withContext(function($ctx2) {
$3=_st(html)._ul();
_st($3)._selectable();
_st($3)._addClass_("nav nav-pills nav-stacked");
_st($3)._at_put_("tabindex","1");
_st($3)._onArrowKeyDown_((function(){
return smalltalk.withContext(function($ctx3) {
return _st(self)._moveSelectionDown();
}, function($ctx3) {$ctx3.fillBlock({},$ctx1)})}));
$4=_st($3)._onArrowKeyUp_((function(){
return smalltalk.withContext(function($ctx3) {
return _st(self)._moveSelectionUp();
}, function($ctx3) {$ctx3.fillBlock({},$ctx1)})}));
self["@listElement"]=$4;
return self["@listElement"];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
_st(self)._overflow_("auto");
_st(self)._getList();
_st(self)._updateContents();
return self}, function($ctx1) {$ctx1.fill(self,"render:with:",{container:container,html:html},smalltalk.PluggableListMorph)})},
args: ["container", "html"],
source: "render: container with: html\x0a\x09xhtml := html.\x0a\x09container\x0a\x09\x09class: 'drag-stop';\x0a\x09\x09with: [listElement := html ul\x0a\x09\x09\x09selectable;\x0a\x09\x09\x09addClass: 'nav nav-pills nav-stacked';\x0a\x09\x09\x09at: 'tabindex' put: '1';\x0a\x09\x09\x09onArrowKeyDown:[self moveSelectionDown];\x0a\x09\x09\x09onArrowKeyUp:[self moveSelectionUp]].\x0a\x09self overflow: 'auto'.\x0a\x09self getList.\x0a\x09self updateContents",
messageSends: ["class:", "with:", "selectable", "ul", "addClass:", "at:put:", "onArrowKeyDown:", "moveSelectionDown", "onArrowKeyUp:", "moveSelectionUp", "overflow:", "getList", "updateContents"],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "selected:",
category: 'not yet classified',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._model())._perform_with_(self["@setIndexSelector"],_st(anObject)._index());
return self}, function($ctx1) {$ctx1.fill(self,"selected:",{anObject:anObject},smalltalk.PluggableListMorph)})},
args: ["anObject"],
source: "selected: anObject\x0a\x09self model perform: setIndexSelector with: anObject index",
messageSends: ["perform:with:", "index", "model"],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "setIndexSelector",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@setIndexSelector"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"setIndexSelector",{},smalltalk.PluggableListMorph)})},
args: [],
source: "setIndexSelector\x0a\x09^setIndexSelector",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "setIndexSelector:",
category: 'not yet classified',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@setIndexSelector"]=anObject;
return self}, function($ctx1) {$ctx1.fill(self,"setIndexSelector:",{anObject:anObject},smalltalk.PluggableListMorph)})},
args: ["anObject"],
source: "setIndexSelector: anObject\x0a\x09setIndexSelector:= anObject",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "update:",
category: 'not yet classified',
fn: function (aSymbol){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2,$3,$4,$5,$6;
$1=_st(_st(aSymbol).__eq_eq(self["@getListSelector"]))._or_((function(){
return smalltalk.withContext(function($ctx2) {
return _st(aSymbol).__eq_eq(self["@getListElementSelector"]);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
if(smalltalk.assert($1)){
_st(self)._updateList();
$2=self;
return $2;
};
$3=_st(aSymbol).__eq_eq(self["@getIndexSelector"]);
if(smalltalk.assert($3)){
_st(self)._selectionIndex_(_st(self)._getCurrentSelectionIndex());
$4=self;
return $4;
};
$5=_st(aSymbol).__eq_eq("allSelections");
if(smalltalk.assert($5)){
_st(self)._selectionIndex_(_st(self)._getCurrentSelectionIndex());
$6=self;
return $6;
};
return self}, function($ctx1) {$ctx1.fill(self,"update:",{aSymbol:aSymbol},smalltalk.PluggableListMorph)})},
args: ["aSymbol"],
source: "update: aSymbol \x0a\x09\x22Refer to the comment in View|update:.\x22\x0a\x0a\x09(aSymbol == getListSelector or: [ aSymbol == getListElementSelector ]) ifTrue: \x0a\x09\x09[self updateList.\x0a\x09\x09^ self].\x0a\x09aSymbol == getIndexSelector ifTrue:\x0a\x09\x09[self selectionIndex: self getCurrentSelectionIndex.\x0a\x09\x09^ self].\x0a\x09aSymbol == #allSelections ifTrue:\x0a\x09\x09[self selectionIndex: self getCurrentSelectionIndex.\x0a\x09\x09^ self].",
messageSends: ["ifTrue:", "updateList", "or:", "==", "selectionIndex:", "getCurrentSelectionIndex"],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "update:with:",
category: 'not yet classified',
fn: function (aSymbol,anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2,$3,$4,$5,$6,$7,$8;
$1=_st(aSymbol).__eq_eq("selected:");
if(smalltalk.assert($1)){
_st(self)._selected_(anObject);
$2=self;
return $2;
};
$3=_st(_st(aSymbol).__eq_eq(self["@getListSelector"]))._or_((function(){
return smalltalk.withContext(function($ctx2) {
return _st(aSymbol).__eq_eq(self["@getListElementSelector"]);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
if(smalltalk.assert($3)){
_st(self)._updateList();
$4=self;
return $4;
};
$5=_st(aSymbol).__eq_eq(self["@getIndexSelector"]);
if(smalltalk.assert($5)){
_st(self)._selectionIndex_(_st(self)._getCurrentSelectionIndex());
$6=self;
return $6;
};
$7=_st(aSymbol).__eq_eq("allSelections");
if(smalltalk.assert($7)){
_st(self)._selectionIndex_(_st(self)._getCurrentSelectionIndex());
$8=self;
return $8;
};
return self}, function($ctx1) {$ctx1.fill(self,"update:with:",{aSymbol:aSymbol,anObject:anObject},smalltalk.PluggableListMorph)})},
args: ["aSymbol", "anObject"],
source: "update: aSymbol with: anObject\x0a\x09\x22Refer to the comment in View|update:.\x22\x0a\x09\x0a\x09aSymbol == #selected: ifTrue: \x0a\x09\x09[self selected: anObject. \x0a\x09\x09^self].\x0a\x09(aSymbol == getListSelector or: [ aSymbol == getListElementSelector ]) ifTrue: \x0a\x09\x09[self updateList.\x0a\x09\x09^ self].\x0a\x09aSymbol == getIndexSelector ifTrue:\x0a\x09\x09[self selectionIndex: self getCurrentSelectionIndex.\x0a\x09\x09^ self].\x0a\x09aSymbol == #allSelections ifTrue:\x0a\x09\x09[self selectionIndex: self getCurrentSelectionIndex.\x0a\x09\x09^ self].",
messageSends: ["ifTrue:", "selected:", "==", "updateList", "or:", "selectionIndex:", "getCurrentSelectionIndex"],
referencedClasses: []
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "updateContents",
category: 'not yet classified',
fn: function (){
var self=this;
var i;
function $LazyListMorph(){return smalltalk.LazyListMorph||(typeof LazyListMorph=="undefined"?nil:LazyListMorph)}
return smalltalk.withContext(function($ctx1) { 
i=(1);
_st(_st(self)._listElement())._empty();
_st(self)._clearEntries();
_st(_st(self)._list())._do_((function(each){
var element;
return smalltalk.withContext(function($ctx2) {
element=_st($LazyListMorph())._index_dependent_content_(i,self,each);
element;
_st(_st(self)._listEntries())._add_(element);
_st(element)._appendToJQuery_(_st(_st(self)._listElement())._asJQuery());
i=_st(i).__plus((1));
return i;
}, function($ctx2) {$ctx2.fillBlock({each:each,element:element},$ctx1)})}));
_st(self)._updateLayout();
return self}, function($ctx1) {$ctx1.fill(self,"updateContents",{i:i},smalltalk.PluggableListMorph)})},
args: [],
source: "updateContents\x0a\x09|i|\x0a\x09i := 1.\x0a\x09self listElement empty.\x0a\x09self clearEntries.\x0a\x09self list do:[:each| |element| \x0a\x09\x09element := LazyListMorph index: i dependent: self content: each.\x0a\x09\x09self listEntries add: element.\x0a\x09\x09element appendToJQuery: self listElement asJQuery.\x0a\x09\x09i := i +1].\x0a\x09self updateLayout",
messageSends: ["empty", "listElement", "clearEntries", "do:", "index:dependent:content:", "add:", "listEntries", "appendToJQuery:", "asJQuery", "+", "list", "updateLayout"],
referencedClasses: ["LazyListMorph"]
}),
smalltalk.PluggableListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "updateList",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
_st(self)._getList();
$1=_st(_st(self)._listElement())._notNil();
if(smalltalk.assert($1)){
_st(self)._updateContents();
};
return self}, function($ctx1) {$ctx1.fill(self,"updateList",{},smalltalk.PluggableListMorph)})},
args: [],
source: "updateList\x0a\x09\x22the list has changed -- update from the model\x22\x0a\x09self getList.\x0a\x09self listElement notNil ifTrue:[self updateContents]",
messageSends: ["getList", "ifTrue:", "updateContents", "notNil", "listElement"],
referencedClasses: []
}),
smalltalk.PluggableListMorph);


smalltalk.addMethod(
smalltalk.method({
selector: "on:list:primarySelection:changePrimarySelection:listSelection:changeListSelection:",
category: 'not yet classified',
fn: function (anObject,listSel,getSelectionSel,setSelectionSel,getListSel,setListSel){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._basicNew();
_st($2)._on_list_primarySelection_changePrimarySelection_listSelection_changeListSelection_(anObject,listSel,getSelectionSel,setSelectionSel,getListSel,setListSel);
_st($2)._initialize();
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"on:list:primarySelection:changePrimarySelection:listSelection:changeListSelection:",{anObject:anObject,listSel:listSel,getSelectionSel:getSelectionSel,setSelectionSel:setSelectionSel,getListSel:getListSel,setListSel:setListSel},smalltalk.PluggableListMorph.klass)})},
args: ["anObject", "listSel", "getSelectionSel", "setSelectionSel", "getListSel", "setListSel"],
source: "on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel\x0a\x09^ self basicNew\x0a\x09\x09\x09on: anObject\x0a\x09\x09\x09list: listSel\x0a\x09\x09\x09primarySelection: getSelectionSel\x0a\x09\x09\x09changePrimarySelection: setSelectionSel\x0a\x09\x09\x09listSelection: getListSel\x0a\x09\x09\x09changeListSelection: setListSel;\x0a\x09\x09initialize;\x0a\x09\x09yourself",
messageSends: ["on:list:primarySelection:changePrimarySelection:listSelection:changeListSelection:", "basicNew", "initialize", "yourself"],
referencedClasses: []
}),
smalltalk.PluggableListMorph.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "tryList",
category: 'not yet classified',
fn: function (){
var self=this;
var listMorph;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
listMorph=_st(self)._basicNew();
$2=listMorph;
_st($2)._list_([(1), (2), (3), (4), (5), (6), (7), (8), (9), (10), (11), (12), (13), (14), (15), (16), (17), (18), (19), (20), (21), (22)]);
_st($2)._model_(listMorph);
_st($2)._getListSelector_("list");
_st($2)._getIndexSelector_("listIndex");
_st($2)._setIndexSelector_("listIndex:");
_st($2)._initialize();
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"tryList",{listMorph:listMorph},smalltalk.PluggableListMorph.klass)})},
args: [],
source: "tryList\x0a|listMorph|\x0a\x09listMorph := self basicNew.\x0a\x09^listMorph\x0a\x09\x09list: #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22);\x0a\x09\x09model: listMorph;\x0a\x09\x09getListSelector: #list;\x0a\x09\x09getIndexSelector: #listIndex;\x0a\x09\x09setIndexSelector: #listIndex:;\x0a\x09\x09initialize;\x0a\x09\x09yourself",
messageSends: ["basicNew", "list:", "model:", "getListSelector:", "getIndexSelector:", "setIndexSelector:", "initialize", "yourself"],
referencedClasses: []
}),
smalltalk.PluggableListMorph.klass);


smalltalk.addClass('RectangleMorph', smalltalk.BorderedMorph, ['morphElement'], 'Canvas');


smalltalk.addClass('AlignmentMorph', smalltalk.RectangleMorph, ['morphElement'], 'Canvas');


smalltalk.addClass('DockingBarMorph', smalltalk.AlignmentMorph, ['morphElement'], 'Canvas');
smalltalk.addMethod(
smalltalk.method({
selector: "adhereTo:",
category: 'private',
fn: function (edgeSymbol){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
$1=_st(["left", "top", "right", "bottom", "none"])._includes_(edgeSymbol);
if(! smalltalk.assert($1)){
$2=_st(self)._error_("invalid option");
return $2;
};
_st(self)._setToAdhereToEdge_(edgeSymbol);
return self}, function($ctx1) {$ctx1.fill(self,"adhereTo:",{edgeSymbol:edgeSymbol},smalltalk.DockingBarMorph)})},
args: ["edgeSymbol"],
source: "adhereTo: edgeSymbol\x0a\x09\x22Options: #left #top #right #bottom or #none\x22\x0a\x09(#(#left #top #right #bottom #none ) includes: edgeSymbol)\x0a\x09\x09ifFalse: [^ self error: 'invalid option'].\x0a\x09self setToAdhereToEdge: edgeSymbol.",
messageSends: ["ifFalse:", "error:", "includes:", "setToAdhereToEdge:"],
referencedClasses: []
}),
smalltalk.DockingBarMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "adhereToBottom",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._adhereTo_("bottom");
_st(self)._width_(_st(_st(_st(self)._owner())._width()).__minus(_st(self)._ownerPadding()));
return self}, function($ctx1) {$ctx1.fill(self,"adhereToBottom",{},smalltalk.DockingBarMorph)})},
args: [],
source: "adhereToBottom\x0a\x09\x22Instract the receiver to adhere to bottom\x22\x0a\x09 self adhereTo:#bottom.\x0a\x09 self width: self owner width - self ownerPadding.",
messageSends: ["adhereTo:", "width:", "-", "ownerPadding", "width", "owner"],
referencedClasses: []
}),
smalltalk.DockingBarMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "adhereToLeft",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._adhereTo_("left");
_st(self)._height_(_st(_st(_st(self)._owner())._height()).__minus(_st(self)._ownerPadding()));
return self}, function($ctx1) {$ctx1.fill(self,"adhereToLeft",{},smalltalk.DockingBarMorph)})},
args: [],
source: "adhereToLeft\x0a\x09\x22Instract the receiver to adhere to left\x22\x0a\x09self adhereTo: #left.\x0a\x09self height: self owner height - self ownerPadding.",
messageSends: ["adhereTo:", "height:", "-", "ownerPadding", "height", "owner"],
referencedClasses: []
}),
smalltalk.DockingBarMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "adhereToRight",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._adhereTo_("right");
_st(self)._height_(_st(_st(_st(self)._owner())._height()).__minus(_st(self)._ownerPadding()));
return self}, function($ctx1) {$ctx1.fill(self,"adhereToRight",{},smalltalk.DockingBarMorph)})},
args: [],
source: "adhereToRight\x0a\x09\x22Instract the receiver to adhere to right\x22\x0a\x09self adhereTo: #right.\x0a\x09self height: self owner height - self ownerPadding.",
messageSends: ["adhereTo:", "height:", "-", "ownerPadding", "height", "owner"],
referencedClasses: []
}),
smalltalk.DockingBarMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "adhereToTop",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._adhereTo_("top");
_st(self)._width_(_st(_st(_st(self)._owner())._width()).__minus(_st(self)._ownerPadding()));
return self}, function($ctx1) {$ctx1.fill(self,"adhereToTop",{},smalltalk.DockingBarMorph)})},
args: [],
source: "adhereToTop\x0a\x09\x22Instract the receiver to adhere to top\x22\x0a\x09self adhereTo: #top.\x0a\x09self width: self owner width - self ownerPadding.",
messageSends: ["adhereTo:", "width:", "-", "ownerPadding", "width", "owner"],
referencedClasses: []
}),
smalltalk.DockingBarMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "ownerChanged",
category: 'submorphs',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
smalltalk.AlignmentMorph.fn.prototype._ownerChanged.apply(_st(self), []);
return self}, function($ctx1) {$ctx1.fill(self,"ownerChanged",{},smalltalk.DockingBarMorph)})},
args: [],
source: "ownerChanged\x0a\x09super ownerChanged.",
messageSends: ["ownerChanged"],
referencedClasses: []
}),
smalltalk.DockingBarMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "updateLayout",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2,$3,$4;
smalltalk.AlignmentMorph.fn.prototype._updateLayout.apply(_st(self), []);
$1=_st(_st(self)._adherentToEdge()).__eq("left");
if(smalltalk.assert($1)){
_st(self)._adhereToLeft();
};
$2=_st(_st(self)._adherentToEdge()).__eq("right");
if(smalltalk.assert($2)){
_st(self)._adhereToRight();
};
$3=_st(_st(self)._adherentToEdge()).__eq("top");
if(smalltalk.assert($3)){
_st(self)._adhereToTop();
};
$4=_st(_st(self)._adherentToEdge()).__eq("bottom");
if(smalltalk.assert($4)){
_st(self)._adhereToBottom();
};
return self}, function($ctx1) {$ctx1.fill(self,"updateLayout",{},smalltalk.DockingBarMorph)})},
args: [],
source: "updateLayout\x0a\x09super updateLayout.\x0a\x09self adherentToEdge = #left ifTrue: [self adhereToLeft].\x0a\x09self adherentToEdge = #right ifTrue: [self adhereToRight].\x0a\x09self adherentToEdge = #top ifTrue: [self adhereToTop].\x0a\x09self adherentToEdge = #bottom ifTrue: [self adhereToBottom].",
messageSends: ["updateLayout", "ifTrue:", "adhereToLeft", "=", "adherentToEdge", "adhereToRight", "adhereToTop", "adhereToBottom"],
referencedClasses: []
}),
smalltalk.DockingBarMorph);



smalltalk.addClass('NavbarMorph', smalltalk.DockingBarMorph, ['morphElement'], 'Canvas');
smalltalk.addMethod(
smalltalk.method({
selector: "render:with:",
category: 'rendering',
fn: function (container,html){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(container)._class_("window-title");
return self}, function($ctx1) {$ctx1.fill(self,"render:with:",{container:container,html:html},smalltalk.NavbarMorph)})},
args: ["container", "html"],
source: "render: container with: html\x0a\x09container\x0a\x09\x09class: 'window-title'.",
messageSends: ["class:"],
referencedClasses: []
}),
smalltalk.NavbarMorph);



smalltalk.addClass('TextMorph', smalltalk.RectangleMorph, ['morphElement', 'editor', 'readOnly', 'selectionStart', 'selectionEnd', 'selectionText', 'textElement', 'text', 'myHtml'], 'Canvas');
smalltalk.addMethod(
smalltalk.method({
selector: "asText",
category: 'converting',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._text();
return $1;
}, function($ctx1) {$ctx1.fill(self,"asText",{},smalltalk.TextMorph)})},
args: [],
source: "asText\x0a\x09^ self text",
messageSends: ["text"],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "bindEvents",
category: 'events handlings',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
smalltalk.RectangleMorph.fn.prototype._bindEvents.apply(_st(self), []);
_st(_st(self)._morphElement())._onKeyPress_((function(evt){
return smalltalk.withContext(function($ctx2) {
_st(evt)._preventDefault();
return _st(self)._performKeyInput_(_st(evt)._charCode());
}, function($ctx2) {$ctx2.fillBlock({evt:evt},$ctx1)})}));
_st(_st(self)._morphElement())._onKeyDown_((function(evt){
return smalltalk.withContext(function($ctx2) {
_st(self)._performKeySpecial_event_(_st(evt)._keyCode(),evt);
return _st(self)._updateCursor();
}, function($ctx2) {$ctx2.fillBlock({evt:evt},$ctx1)})}));
return self}, function($ctx1) {$ctx1.fill(self,"bindEvents",{},smalltalk.TextMorph)})},
args: [],
source: "bindEvents\x0a\x09super bindEvents.\x0a\x09self morphElement onKeyPress: [:evt |\x0a\x09\x09evt preventDefault.\x0a\x09\x09self performKeyInput: evt charCode].\x0a\x09self morphElement onKeyDown: [:evt | \x0a\x09\x09self performKeySpecial: evt keyCode event: evt.\x0a\x09\x09self updateCursor].",
messageSends: ["bindEvents", "onKeyPress:", "preventDefault", "performKeyInput:", "charCode", "morphElement", "onKeyDown:", "performKeySpecial:event:", "keyCode", "updateCursor"],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "contents",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._text();
return $1;
}, function($ctx1) {$ctx1.fill(self,"contents",{},smalltalk.TextMorph)})},
args: [],
source: "contents\x0a\x09^ self text",
messageSends: ["text"],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "editor",
category: 'pharo compatibility',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
$1=self["@editor"];
if(($receiver = $1) == nil || $receiver == undefined){
self["@editor"]=_st(_st(self)._editorClass())._forMorph_(self);
self["@editor"];
} else {
$1;
};
$2=self["@editor"];
return $2;
}, function($ctx1) {$ctx1.fill(self,"editor",{},smalltalk.TextMorph)})},
args: [],
source: "editor\x0a\x09editor ifNil: [editor := self editorClass forMorph: self].\x0a\x09^ editor",
messageSends: ["ifNil:", "forMorph:", "editorClass"],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "editorClass",
category: 'pharo compatibility',
fn: function (){
var self=this;
function $SmalltalkEditor(){return smalltalk.SmalltalkEditor||(typeof SmalltalkEditor=="undefined"?nil:SmalltalkEditor)}
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=$SmalltalkEditor();
return $1;
}, function($ctx1) {$ctx1.fill(self,"editorClass",{},smalltalk.TextMorph)})},
args: [],
source: "editorClass\x0a\x09^ SmalltalkEditor",
messageSends: [],
referencedClasses: ["SmalltalkEditor"]
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "escape:",
category: 'rendering',
fn: function (aString){
var self=this;
var str;
return smalltalk.withContext(function($ctx1) { 
var $1;
str=aString;
_st(_st(_st(self)._class())._charSpecialRenderings())._keysAndValuesDo_((function(char,escape){
return smalltalk.withContext(function($ctx2) {
str=_st(str)._copyReplaceAll_with_(char,escape);
return str;
}, function($ctx2) {$ctx2.fillBlock({char:char,escape:escape},$ctx1)})}));
$1=str;
return $1;
}, function($ctx1) {$ctx1.fill(self,"escape:",{aString:aString,str:str},smalltalk.TextMorph)})},
args: ["aString"],
source: "escape: aString\x0a\x09|str|\x0a\x09str := aString.\x0a\x09self class charSpecialRenderings keysAndValuesDo: [:char :escape |\x0a\x09\x09str := str copyReplaceAll: char with: escape].\x0a\x09^str",
messageSends: ["keysAndValuesDo:", "copyReplaceAll:with:", "charSpecialRenderings", "class"],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "getColorStringFor:",
category: 'rendering',
fn: function (aColor){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st("#").__comma(_st(aColor)._forHtml());
return $1;
}, function($ctx1) {$ctx1.fill(self,"getColorStringFor:",{aColor:aColor},smalltalk.TextMorph)})},
args: ["aColor"],
source: "getColorStringFor: aColor\x0a\x09^'#', aColor forHtml",
messageSends: [",", "forHtml"],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "getCssClassFor:",
category: 'rendering',
fn: function (aCode){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2,$3,$4,$5;
$1=_st(aCode).__eq((1));
if(smalltalk.assert($1)){
return "bold";
};
$2=_st(aCode).__eq((2));
if(smalltalk.assert($2)){
return "italic";
};
$3=_st(aCode).__eq((0));
if(smalltalk.assert($3)){
return "";
};
$4=_st(aCode).__eq((16));
if(smalltalk.assert($4)){
return "struck";
};
$5=_st(aCode).__eq((4));
if(smalltalk.assert($5)){
return "underlined";
};
return self}, function($ctx1) {$ctx1.fill(self,"getCssClassFor:",{aCode:aCode},smalltalk.TextMorph)})},
args: ["aCode"],
source: "getCssClassFor: aCode\x0a\x09aCode = 1 ifTrue: [^'bold'].\x0a\x09aCode = 2 ifTrue: [^'italic'].\x0a\x09aCode = 0 ifTrue: [^''].\x0a\x09aCode = 16 ifTrue: [^'struck'].\x0a\x09aCode = 4 ifTrue: [^'underlined']",
messageSends: ["ifTrue:", "="],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "initialize",
category: 'initializing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
smalltalk.RectangleMorph.fn.prototype._initialize.apply(_st(self), []);
_st(self)._initializeCursor();
_st(self)._initializeCallbacks();
return self}, function($ctx1) {$ctx1.fill(self,"initialize",{},smalltalk.TextMorph)})},
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09self initializeCursor.\x0a\x09self initializeCallbacks.",
messageSends: ["initialize", "initializeCursor", "initializeCallbacks"],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "initializeCallbacks",
category: 'initializing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._textElement())._onKeyUp_((function(){
return smalltalk.withContext(function($ctx2) {
return _st(self)._updateCursor();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
_st(_st(self)._textElement())._onMouseUp_((function(){
return smalltalk.withContext(function($ctx2) {
return _st(self)._updateCursor();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
return self}, function($ctx1) {$ctx1.fill(self,"initializeCallbacks",{},smalltalk.TextMorph)})},
args: [],
source: "initializeCallbacks\x0a\x09self textElement onKeyUp: [self updateCursor].\x0a\x09self textElement onMouseUp: [self updateCursor].",
messageSends: ["onKeyUp:", "updateCursor", "textElement", "onMouseUp:"],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "initializeCursor",
category: 'initializing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._setSelectionFrom_to_((1),(1));
_st(self)._updateCursor();
return self}, function($ctx1) {$ctx1.fill(self,"initializeCursor",{},smalltalk.TextMorph)})},
args: [],
source: "initializeCursor\x0a\x09self setSelectionFrom: 1 to: 1.\x0a\x09self updateCursor.",
messageSends: ["setSelectionFrom:to:", "updateCursor"],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "keyBackspace:",
category: 'events handlings',
fn: function (evt){
var self=this;
var start,end,len,newPos;
function $KeyboardEvent(){return smalltalk.KeyboardEvent||(typeof KeyboardEvent=="undefined"?nil:KeyboardEvent)}
return smalltalk.withContext(function($ctx1) { 
var $1;
_st(evt)._preventDefault();
start=_st(self)._selectionStart();
end=_st(self)._selectionEnd();
len=_st(self)._selectionLength();
$1=_st(len).__eq((0));
if(smalltalk.assert($1)){
_st(self)._text_(_st(_st(self)._text())._replaceFrom_to_with_(_st(start).__minus((1)),end,""));
newPos=_st(start).__minus((1));
newPos;
} else {
_st(self)._text_(_st(_st(self)._text())._replaceFrom_to_with_(start,end,""));
newPos=start;
newPos;
};
newPos=_st(newPos)._max_((1));
_st(self)._setSelectionFrom_to_(newPos,_st(newPos).__minus((1)));
_st(self)._updateCursor();
_st(self)._keyStroke_(_st($KeyboardEvent())._value_((8)));
return self}, function($ctx1) {$ctx1.fill(self,"keyBackspace:",{evt:evt,start:start,end:end,len:len,newPos:newPos},smalltalk.TextMorph)})},
args: ["evt"],
source: "keyBackspace: evt\x0a\x09|start end len newPos|\x0a\x09evt preventDefault.\x0a\x09start := self selectionStart.\x0a\x09end := self selectionEnd.\x0a\x09len := self selectionLength.\x0a\x09len = 0\x0a\x09\x09ifTrue: [\x0a\x09\x09\x09self text: (self text replaceFrom: start - 1 to: end with: '').\x0a\x09\x09\x09newPos := start - 1]\x0a\x09\x09ifFalse: [\x0a\x09\x09\x09self text: (self text replaceFrom: start to: end with: '').\x0a\x09\x09\x09newPos := start].\x0a\x09newPos := newPos max: 1.\x0a\x09self setSelectionFrom: newPos to: newPos - 1.\x0a\x09self updateCursor.\x0a\x09self keyStroke: (KeyboardEvent value: 8).",
messageSends: ["preventDefault", "selectionStart", "selectionEnd", "selectionLength", "ifTrue:ifFalse:", "text:", "replaceFrom:to:with:", "-", "text", "=", "max:", "setSelectionFrom:to:", "updateCursor", "keyStroke:", "value:"],
referencedClasses: ["KeyboardEvent"]
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "keyDelete:",
category: 'events handlings',
fn: function (evt){
var self=this;
var start,end,len,newPos;
function $KeyboardEvent(){return smalltalk.KeyboardEvent||(typeof KeyboardEvent=="undefined"?nil:KeyboardEvent)}
return smalltalk.withContext(function($ctx1) { 
var $1;
_st(evt)._preventDefault();
start=_st(self)._selectionStart();
end=_st(self)._selectionEnd();
len=_st(self)._selectionLength();
$1=_st(len).__eq((0));
if(smalltalk.assert($1)){
_st(self)._text_(_st(_st(self)._text())._replaceFrom_to_with_(start,_st(end).__plus((1)),""));
} else {
_st(self)._text_(_st(_st(self)._text())._replaceFrom_to_with_(start,end,""));
};
newPos=start;
_st(self)._setSelectionFrom_to_(newPos,_st(newPos).__minus((1)));
_st(self)._updateCursor();
_st(self)._keyStroke_(_st($KeyboardEvent())._value_((46)));
return self}, function($ctx1) {$ctx1.fill(self,"keyDelete:",{evt:evt,start:start,end:end,len:len,newPos:newPos},smalltalk.TextMorph)})},
args: ["evt"],
source: "keyDelete: evt\x0a\x09|start end len newPos|\x0a\x09evt preventDefault.\x0a\x09start := self selectionStart.\x0a\x09end := self selectionEnd.\x0a\x09len := self selectionLength.\x0a\x09len = 0\x0a\x09\x09ifTrue: [\x0a\x09\x09\x09self text: (self text replaceFrom: start to: end + 1 with: '')]\x0a\x09\x09ifFalse: [\x0a\x09\x09\x09self text: (self text replaceFrom: start to: end with: '')].\x0a\x09newPos := start.\x0a\x09self setSelectionFrom: newPos to: newPos - 1.\x0a\x09self updateCursor.\x0a\x09self keyStroke: (KeyboardEvent value: 46).",
messageSends: ["preventDefault", "selectionStart", "selectionEnd", "selectionLength", "ifTrue:ifFalse:", "text:", "replaceFrom:to:with:", "+", "text", "=", "setSelectionFrom:to:", "-", "updateCursor", "keyStroke:", "value:"],
referencedClasses: ["KeyboardEvent"]
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "keyReturn:",
category: 'events handlings',
fn: function (evt){
var self=this;
var start,end,len,newPos,character;
function $Character(){return smalltalk.Character||(typeof Character=="undefined"?nil:Character)}
function $KeyboardEvent(){return smalltalk.KeyboardEvent||(typeof KeyboardEvent=="undefined"?nil:KeyboardEvent)}
return smalltalk.withContext(function($ctx1) { 
var $1;
_st(evt)._preventDefault();
start=_st(self)._selectionStart();
end=_st(self)._selectionEnd();
len=_st(self)._selectionLength();
character=_st($Character())._cr();
$1=_st(len).__eq((0));
if(smalltalk.assert($1)){
_st(self)._text_(_st(_st(self)._text())._replaceFrom_to_with_(start,end,character));
newPos=_st(start).__plus((1));
newPos;
} else {
_st(self)._text_(_st(_st(self)._text())._replaceFrom_to_with_(start,end,character));
newPos=_st(start).__plus((1));
newPos;
};
_st(self)._setSelectionFrom_to_(newPos,_st(newPos).__minus((1)));
_st(self)._updateCursor();
_st(self)._keyStroke_(_st($KeyboardEvent())._value_((13)));
return self}, function($ctx1) {$ctx1.fill(self,"keyReturn:",{evt:evt,start:start,end:end,len:len,newPos:newPos,character:character},smalltalk.TextMorph)})},
args: ["evt"],
source: "keyReturn: evt\x0a\x09|start end len newPos character|\x0a\x09evt preventDefault.\x0a\x09start := self selectionStart.\x0a\x09end := self selectionEnd.\x0a\x09len := self selectionLength.\x0a\x09character := Character cr.\x0a\x09len = 0\x0a\x09\x09ifTrue: [\x0a\x09\x09\x09self text: (self text replaceFrom: start to: end with: character).\x0a\x09\x09\x09newPos := start + 1]\x0a\x09\x09ifFalse: [\x0a\x09\x09\x09self text: (self text replaceFrom: start to: end with: character).\x0a\x09\x09\x09newPos := start + 1].\x0a\x09self setSelectionFrom: newPos to: newPos - 1.\x0a\x09self updateCursor.\x0a\x09self keyStroke: (KeyboardEvent value: 13).",
messageSends: ["preventDefault", "selectionStart", "selectionEnd", "selectionLength", "cr", "ifTrue:ifFalse:", "text:", "replaceFrom:to:with:", "text", "+", "=", "setSelectionFrom:to:", "-", "updateCursor", "keyStroke:", "value:"],
referencedClasses: ["Character", "KeyboardEvent"]
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "keyStroke:",
category: 'events handlings',
fn: function (evt){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._changed_with_("keyInput",evt);
_st(_st(self)._editor())._keyStroke_(evt);
return self}, function($ctx1) {$ctx1.fill(self,"keyStroke:",{evt:evt},smalltalk.TextMorph)})},
args: ["evt"],
source: "keyStroke: evt\x0a\x09self changed: #keyInput with: evt.\x0a\x09self editor keyStroke: evt.",
messageSends: ["changed:with:", "keyStroke:", "editor"],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "newContents:",
category: 'accessing',
fn: function (stringOrText){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._text_(stringOrText);
return self}, function($ctx1) {$ctx1.fill(self,"newContents:",{stringOrText:stringOrText},smalltalk.TextMorph)})},
args: ["stringOrText"],
source: "newContents: stringOrText\x0a\x09self text: stringOrText.",
messageSends: ["text:"],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "performKeyInput:",
category: 'events handlings',
fn: function (anInteger){
var self=this;
var newPos,character;
function $String(){return smalltalk.String||(typeof String=="undefined"?nil:String)}
function $KeyboardEvent(){return smalltalk.KeyboardEvent||(typeof KeyboardEvent=="undefined"?nil:KeyboardEvent)}
return smalltalk.withContext(function($ctx1) { 
newPos=_st(_st(self)._selectionStart()).__plus((1));
character=_st($String())._fromCharCode_(anInteger);
_st(_st(self)._text())._replaceFrom_to_with_(_st(self)._selectionStart(),_st(self)._selectionEnd(),character);
_st(self)._text_(_st(self)._text());
_st(self)._setSelectionFrom_to_(newPos,_st(newPos).__minus((1)));
_st(self)._updateCursor();
_st(self)._keyStroke_(_st($KeyboardEvent())._value_(anInteger));
return self}, function($ctx1) {$ctx1.fill(self,"performKeyInput:",{anInteger:anInteger,newPos:newPos,character:character},smalltalk.TextMorph)})},
args: ["anInteger"],
source: "performKeyInput: anInteger\x0a\x09|newPos character|\x0a\x09newPos := self selectionStart + 1.\x0a\x09character := String fromCharCode: anInteger.\x0a\x09self text replaceFrom: self selectionStart to: self selectionEnd with: character.\x0a\x09self text: self text.\x0a\x09self setSelectionFrom: newPos to: newPos - 1.\x0a\x09self updateCursor.\x0a\x09self keyStroke: (KeyboardEvent value: anInteger).",
messageSends: ["+", "selectionStart", "fromCharCode:", "replaceFrom:to:with:", "selectionEnd", "text", "text:", "setSelectionFrom:to:", "-", "updateCursor", "keyStroke:", "value:"],
referencedClasses: ["String", "KeyboardEvent"]
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "performKeySpecial:event:",
category: 'events handlings',
fn: function (anInteger,evt){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(self)._class())._keySpecialBindings())._includesKey_(anInteger);
if(smalltalk.assert($1)){
_st(self)._perform_withArguments_(_st(_st(_st(self)._class())._keySpecialBindings())._at_(anInteger),[evt]);
return true;
} else {
return false;
};
return self}, function($ctx1) {$ctx1.fill(self,"performKeySpecial:event:",{anInteger:anInteger,evt:evt},smalltalk.TextMorph)})},
args: ["anInteger", "evt"],
source: "performKeySpecial: anInteger event: evt\x0a\x09(self class keySpecialBindings includesKey: anInteger)\x0a\x09\x09ifTrue: [self perform: (self class keySpecialBindings at: anInteger) withArguments: {evt}. ^ true]\x0a\x09\x09ifFalse: [^ false].",
messageSends: ["ifTrue:ifFalse:", "perform:withArguments:", "at:", "keySpecialBindings", "class", "includesKey:"],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "privateText:",
category: 'accessing',
fn: function (aText){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@text"]=aText;
return self}, function($ctx1) {$ctx1.fill(self,"privateText:",{aText:aText},smalltalk.TextMorph)})},
args: ["aText"],
source: "privateText: aText\x0a\x09text := aText.",
messageSends: [],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "readOnly",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
$1=self["@readOnly"];
if(($receiver = $1) == nil || $receiver == undefined){
self["@readOnly"]=true;
self["@readOnly"];
} else {
$1;
};
$2=self["@readOnly"];
return $2;
}, function($ctx1) {$ctx1.fill(self,"readOnly",{},smalltalk.TextMorph)})},
args: [],
source: "readOnly\x0a\x09readOnly ifNil: [readOnly := true].\x0a\x09^ readOnly",
messageSends: ["ifNil:"],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "readOnly:",
category: 'accessing',
fn: function (aBoolean){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
self["@readOnly"]=aBoolean;
_st(_st(self)._textElement())._contentEditable_(_st(aBoolean)._not());
$1=aBoolean;
if(smalltalk.assert($1)){
_st(_st(self)._morphElement())._removeClass_("drag-stop");
} else {
_st(_st(self)._morphElement())._addClass_("drag-stop");
};
return self}, function($ctx1) {$ctx1.fill(self,"readOnly:",{aBoolean:aBoolean},smalltalk.TextMorph)})},
args: ["aBoolean"],
source: "readOnly: aBoolean\x0a\x09readOnly := aBoolean.\x0a\x09self textElement contentEditable: aBoolean not.\x0a\x09aBoolean\x0a\x09\x09ifTrue: [self morphElement removeClass: 'drag-stop']\x0a\x09\x09ifFalse: [self morphElement addClass: 'drag-stop']",
messageSends: ["contentEditable:", "not", "textElement", "ifTrue:ifFalse:", "removeClass:", "morphElement", "addClass:"],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "render:with:",
category: 'rendering',
fn: function (container,html){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@myHtml"]=html;
_st(container)._with_((function(){
return smalltalk.withContext(function($ctx2) {
self["@textElement"]=_st(_st(html)._span())._class_("content-editable");
return self["@textElement"];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
return self}, function($ctx1) {$ctx1.fill(self,"render:with:",{container:container,html:html},smalltalk.TextMorph)})},
args: ["container", "html"],
source: "render: container with: html\x0a\x09myHtml := html.\x0a\x09container \x0a\x09\x09with: [textElement := html span class: 'content-editable'].",
messageSends: ["with:", "class:", "span"],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "renderCharacter:",
category: 'rendering',
fn: function (aCharacter){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._textElement())._with_(_st(_st(_st(self)._class())._charSpecialRenderings())._at_ifAbsent_(aCharacter,(function(){
return smalltalk.withContext(function($ctx2) {
return aCharacter;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})})));
return self}, function($ctx1) {$ctx1.fill(self,"renderCharacter:",{aCharacter:aCharacter},smalltalk.TextMorph)})},
args: ["aCharacter"],
source: "renderCharacter: aCharacter\x0a\x09self textElement\x0a\x09\x09with: (self class charSpecialRenderings at: aCharacter ifAbsent: [aCharacter]).",
messageSends: ["with:", "at:ifAbsent:", "charSpecialRenderings", "class", "textElement"],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "renderText:",
category: 'rendering',
fn: function (aText){
var self=this;
var runArr,string,htmlString,offset,spans;
function $Array(){return smalltalk.Array||(typeof Array=="undefined"?nil:Array)}
function $Transcript(){return smalltalk.Transcript||(typeof Transcript=="undefined"?nil:Transcript)}
return smalltalk.withContext(function($ctx1) { 
var $1;
_st(_st(_st(self)._textElement())._asJQuery())._empty();
string=_st(aText)._string();
runArr=_st(aText)._runs();
offset=(1);
spans=_st($Array())._new();
_st($Transcript())._show_(_st(runArr)._size());
_st((1))._to_do_(_st(_st(runArr)._runs())._size(),(function(x){
var endOffs,span,str;
return smalltalk.withContext(function($ctx2) {
endOffs=_st(offset).__plus(_st(_st(runArr)._runs())._at_(x));
endOffs;
str=_st(string)._copyFrom_to_(offset,_st(endOffs).__minus((1)));
str;
span=_st(self["@myHtml"])._span();
span;
_st(_st(span)._asJQuery())._html_(_st(self)._escape_(str));
_st(_st(_st(runArr)._values())._at_(x))._do_((function(value){
return smalltalk.withContext(function($ctx3) {
$1=_st(_st(value)._class())._canUnderstand_("color");
if(smalltalk.assert($1)){
return _st(span)._css_value_("color",_st(self)._getColorStringFor_(_st(value)._color()));
} else {
return _st(span)._addClass_(_st(self)._getCssClassFor_(_st(value)._emphasisCode()));
};
}, function($ctx3) {$ctx3.fillBlock({value:value},$ctx1)})}));
_st(spans)._addLast_(span);
offset=endOffs;
return offset;
}, function($ctx2) {$ctx2.fillBlock({x:x,endOffs:endOffs,span:span,str:str},$ctx1)})}));
_st(spans)._do_((function(span){
return smalltalk.withContext(function($ctx2) {
return _st(_st(self)._textElement())._with_(span);
}, function($ctx2) {$ctx2.fillBlock({span:span},$ctx1)})}));
_st(_st(self)._textElement())._with_((function(){
return smalltalk.withContext(function($ctx2) {
return _st(self["@myHtml"])._br();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
return self}, function($ctx1) {$ctx1.fill(self,"renderText:",{aText:aText,runArr:runArr,string:string,htmlString:htmlString,offset:offset,spans:spans},smalltalk.TextMorph)})},
args: ["aText"],
source: "renderText: aText\x0a\x09|runArr string htmlString offset spans|\x0a\x09self textElement asJQuery empty.\x0a\x09string := aText string.\x0a\x09runArr := aText runs.\x0a\x09offset := 1.\x0a\x09spans := Array new.\x0a\x09Transcript show: runArr size.\x0a\x091 to: runArr runs size do: [:x| |endOffs span str|\x0a\x09\x09endOffs := offset + (runArr runs at: x).\x0a\x09\x09str := string copyFrom: offset to: (endOffs -1).\x0a\x09\x09span := myHtml span.\x0a\x09\x09span asJQuery html: (self escape: str).\x0a\x09\x09(runArr values at: x) do:[:value| \x0a\x09\x09\x09(value class canUnderstand: #color) ifTrue:[\x0a\x09\x09\x09\x09span css: 'color' value: (self getColorStringFor: value color).] \x0a\x09\x09\x09ifFalse:[\x0a\x09\x09\x09\x09span addClass: (self getCssClassFor: value emphasisCode)]].\x0a\x09\x09spans addLast: span.\x0a\x09\x09offset := endOffs].\x09\x0a\x09spans do: [:span| self textElement with: span].\x0a\x09self textElement with: [myHtml br].",
messageSends: ["empty", "asJQuery", "textElement", "string", "runs", "new", "show:", "size", "to:do:", "+", "at:", "copyFrom:to:", "-", "span", "html:", "escape:", "do:", "ifTrue:ifFalse:", "css:value:", "getColorStringFor:", "color", "addClass:", "getCssClassFor:", "emphasisCode", "canUnderstand:", "class", "values", "addLast:", "with:", "br"],
referencedClasses: ["Array", "Transcript"]
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "selectionEnd",
category: 'interactions',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@selectionEnd"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"selectionEnd",{},smalltalk.TextMorph)})},
args: [],
source: "selectionEnd\x0a\x09^ selectionEnd",
messageSends: [],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "selectionLength",
category: 'interactions',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(_st(self)._selectionEnd()).__minus(_st(self)._selectionStart())).__plus((1));
return $1;
}, function($ctx1) {$ctx1.fill(self,"selectionLength",{},smalltalk.TextMorph)})},
args: [],
source: "selectionLength\x0a\x09^ self selectionEnd -  self selectionStart + 1",
messageSends: ["+", "-", "selectionStart", "selectionEnd"],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "selectionStart",
category: 'interactions',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@selectionStart"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"selectionStart",{},smalltalk.TextMorph)})},
args: [],
source: "selectionStart\x0a\x09^ selectionStart",
messageSends: [],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "setSelectionFrom:to:",
category: 'interactions',
fn: function (start,end){
var self=this;
return smalltalk.withContext(function($ctx1) { 
 setSelectionRange(self._textElement()._asJQuery()[0], start - 1, end); ;
return self}, function($ctx1) {$ctx1.fill(self,"setSelectionFrom:to:",{start:start,end:end},smalltalk.TextMorph)})},
args: ["start", "end"],
source: "setSelectionFrom: start to: end\x0a\x09< setSelectionRange(self._textElement()._asJQuery()[0], start - 1, end); >",
messageSends: [],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "text",
category: 'accessing',
fn: function (){
var self=this;
function $Text(){return smalltalk.Text||(typeof Text=="undefined"?nil:Text)}
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
$1=self["@text"];
if(($receiver = $1) == nil || $receiver == undefined){
_st(self)._privateText_(_st($Text())._new());
} else {
$1;
};
$2=self["@text"];
return $2;
}, function($ctx1) {$ctx1.fill(self,"text",{},smalltalk.TextMorph)})},
args: [],
source: "text\x0a\x09text ifNil: [self privateText: Text new].\x0a\x09^ text",
messageSends: ["ifNil:", "privateText:", "new"],
referencedClasses: ["Text"]
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "text:",
category: 'accessing',
fn: function (textOrString){
var self=this;
function $Text(){return smalltalk.Text||(typeof Text=="undefined"?nil:Text)}
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(textOrString)._isString();
if(smalltalk.assert($1)){
_st(self)._privateText_(_st($Text())._fromString_(textOrString));
} else {
_st(self)._privateText_(textOrString);
};
_st(self)._renderText_(_st(self)._text());
return self}, function($ctx1) {$ctx1.fill(self,"text:",{textOrString:textOrString},smalltalk.TextMorph)})},
args: ["textOrString"],
source: "text: textOrString\x0a\x09textOrString isString \x0a\x09\x09ifTrue: [self privateText: (Text fromString: textOrString)]\x0a\x09\x09ifFalse: [self privateText: textOrString].\x0a\x09self renderText: self text.",
messageSends: ["ifTrue:ifFalse:", "privateText:", "fromString:", "isString", "renderText:", "text"],
referencedClasses: ["Text"]
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "textElement",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@textElement"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"textElement",{},smalltalk.TextMorph)})},
args: [],
source: "textElement\x0a\x09^ textElement",
messageSends: [],
referencedClasses: []
}),
smalltalk.TextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "updateCursor",
category: 'interactions',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
 
	// TODO: only for Chrome
	var range = window.getSelection().getRangeAt(0);
	var preCaretRange = range.cloneRange();
	preCaretRange.selectNodeContents(self._textElement()._asJQuery()[0]);
	preCaretRange.setEnd(range.endContainer, range.endOffset);
	var clonedSelection = preCaretRange.cloneContents();
	var div = document.createElement('div');
	div.appendChild(clonedSelection);
	// workaround: Amber does not support writing the tag brackets in String (syntax error)
	var brTag = String.fromCharCode(60) + 'br' + String.fromCharCode(62);
	var divBrs = div.innerHTML.match(new RegExp(brTag, 'g'));
	var countBrs = divBrs ? divBrs.length : 0;
	self['@selectionEnd'] = preCaretRange.toString().length + countBrs;
	self['@selectionText'] = window.getSelection().toString();
	self['@selectionStart'] = self['@selectionEnd'] + 1 - self['@selectionText'].length
	;
return self}, function($ctx1) {$ctx1.fill(self,"updateCursor",{},smalltalk.TextMorph)})},
args: [],
source: "updateCursor\x0a\x09< \x0a\x09// TODO: only for Chrome\x0a\x09var range = window.getSelection().getRangeAt(0);\x0a\x09var preCaretRange = range.cloneRange();\x0a\x09preCaretRange.selectNodeContents(self._textElement()._asJQuery()[0]);\x0a\x09preCaretRange.setEnd(range.endContainer, range.endOffset);\x0a\x09var clonedSelection = preCaretRange.cloneContents();\x0a\x09var div = document.createElement('div');\x0a\x09div.appendChild(clonedSelection);\x0a\x09// workaround: Amber does not support writing the tag brackets in String (syntax error)\x0a\x09var brTag = String.fromCharCode(60) + 'br' + String.fromCharCode(62);\x0a\x09var divBrs = div.innerHTML.match(new RegExp(brTag, 'g'));\x0a\x09var countBrs = divBrs ? divBrs.length : 0;\x0a\x09self['@selectionEnd'] = preCaretRange.toString().length + countBrs;\x0a\x09self['@selectionText'] = window.getSelection().toString();\x0a\x09self['@selectionStart'] = self['@selectionEnd'] + 1 - self['@selectionText'].length\x0a\x09>",
messageSends: [],
referencedClasses: []
}),
smalltalk.TextMorph);


smalltalk.TextMorph.klass.iVarNames = ['keySpecialBindings','charSpecialRenderings'];
smalltalk.addMethod(
smalltalk.method({
selector: "charSpecialRenderings",
category: 'rendering',
fn: function (){
var self=this;
function $Dictionary(){return smalltalk.Dictionary||(typeof Dictionary=="undefined"?nil:Dictionary)}
function $Character(){return smalltalk.Character||(typeof Character=="undefined"?nil:Character)}
return smalltalk.withContext(function($ctx1) { 
var $1,$2,$3,$4;
$1=self["@charSpecialRenderings"];
if(($receiver = $1) == nil || $receiver == undefined){
$2=_st($Dictionary())._new();
_st($2)._at_put_("&","&amp;");
_st($2)._at_put_(_st($Character())._space(),"&nbsp;");
_st($2)._at_put_("<","&lt;");
_st($2)._at_put_(">","&gt;");
_st($2)._at_put_(_st($Character())._tab(),"&#09;");
_st($2)._at_put_(_st($Character())._cr(),"<br/>");
$3=_st($2)._yourself();
self["@charSpecialRenderings"]=$3;
self["@charSpecialRenderings"];
} else {
$1;
};
$4=self["@charSpecialRenderings"];
return $4;
}, function($ctx1) {$ctx1.fill(self,"charSpecialRenderings",{},smalltalk.TextMorph.klass)})},
args: [],
source: "charSpecialRenderings\x0a\x09charSpecialRenderings ifNil: [\x0a\x09\x09charSpecialRenderings := Dictionary new\x0a\x09\x09\x09at: '&' put: '&amp;';\x0a\x09\x09\x09at: Character space put: '&nbsp;';\x0a\x09\x09\x09at: '<' put: '&lt;';\x0a\x09\x09\x09at: '>' put: '&gt;';\x0a\x09\x09\x09at: Character tab put: '&#09;';\x0a\x09\x09\x09at: Character cr put: '<br/>';\x0a\x09\x09\x09yourself].\x0a\x09^ charSpecialRenderings",
messageSends: ["ifNil:", "at:put:", "new", "space", "tab", "cr", "yourself"],
referencedClasses: ["Dictionary", "Character"]
}),
smalltalk.TextMorph.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "keySpecialBindings",
category: 'interactions',
fn: function (){
var self=this;
function $Dictionary(){return smalltalk.Dictionary||(typeof Dictionary=="undefined"?nil:Dictionary)}
return smalltalk.withContext(function($ctx1) { 
var $1,$2,$3,$4;
$1=self["@keySpecialBindings"];
if(($receiver = $1) == nil || $receiver == undefined){
$2=_st($Dictionary())._new();
_st($2)._at_put_((8),"keyBackspace:");
_st($2)._at_put_((46),"keyDelete:");
_st($2)._at_put_((13),"keyReturn:");
$3=_st($2)._yourself();
self["@keySpecialBindings"]=$3;
self["@keySpecialBindings"];
} else {
$1;
};
$4=self["@keySpecialBindings"];
return $4;
}, function($ctx1) {$ctx1.fill(self,"keySpecialBindings",{},smalltalk.TextMorph.klass)})},
args: [],
source: "keySpecialBindings\x0a\x09keySpecialBindings ifNil: [\x0a\x09\x09keySpecialBindings := Dictionary new\x0a\x09\x09\x09at: 8 put: #keyBackspace:;\x0a\x09\x09\x09at: 46 put: #keyDelete:;\x0a\x09\x09\x09at: 13 put: #keyReturn:;\x0a\x09\x09\x09yourself].\x0a\x09^ keySpecialBindings",
messageSends: ["ifNil:", "at:put:", "new", "yourself"],
referencedClasses: ["Dictionary"]
}),
smalltalk.TextMorph.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "new:",
category: 'instance creation',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._new();
_st($2)._text_(aString);
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"new:",{aString:aString},smalltalk.TextMorph.klass)})},
args: ["aString"],
source: "new: aString\x0a\x09^ self new\x0a\x09\x09text: aString;\x0a\x09\x09yourself",
messageSends: ["text:", "new", "yourself"],
referencedClasses: []
}),
smalltalk.TextMorph.klass);


smalltalk.addClass('GlyphIconMorph', smalltalk.Morph, ['morphElement', 'icon', 'spin'], 'Canvas');
smalltalk.addMethod(
smalltalk.method({
selector: "cssClasses",
category: 'rendering',
fn: function (){
var self=this;
var str;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
str=_st("icon-").__comma(_st(self)._icon());
$1=_st(self)._spin();
if(smalltalk.assert($1)){
str=_st(str).__comma(" icon-spin");
str;
};
$2=str;
return $2;
}, function($ctx1) {$ctx1.fill(self,"cssClasses",{str:str},smalltalk.GlyphIconMorph)})},
args: [],
source: "cssClasses\x0a\x09|str|\x0a\x09str := 'icon-', self icon.\x0a\x09self spin ifTrue: [str := str, ' icon-spin'].\x0a\x09^ str",
messageSends: [",", "icon", "ifTrue:", "spin"],
referencedClasses: []
}),
smalltalk.GlyphIconMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "icon",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
$1=self["@icon"];
if(($receiver = $1) == nil || $receiver == undefined){
_st(self)._icon_("star");
} else {
$1;
};
$2=self["@icon"];
return $2;
}, function($ctx1) {$ctx1.fill(self,"icon",{},smalltalk.GlyphIconMorph)})},
args: [],
source: "icon\x0a\x09icon ifNil: [self icon: 'star'].\x0a\x09^ icon",
messageSends: ["ifNil:", "icon:"],
referencedClasses: []
}),
smalltalk.GlyphIconMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "icon:",
category: 'accessing',
fn: function (anIcon){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self["@icon"]).__tild_tild(nil);
if(smalltalk.assert($1)){
_st(self)._removeClass_(_st("icon-").__comma(_st(self)._icon()));
};
self["@icon"]=anIcon;
_st(self)._addClass_(_st("icon-").__comma(anIcon));
return self}, function($ctx1) {$ctx1.fill(self,"icon:",{anIcon:anIcon},smalltalk.GlyphIconMorph)})},
args: ["anIcon"],
source: "icon: anIcon\x0a\x09icon ~~ nil ifTrue: [self removeClass: 'icon-', self icon].\x0a\x09icon := anIcon.\x0a\x09self addClass: 'icon-', anIcon.",
messageSends: ["ifTrue:", "removeClass:", ",", "icon", "~~", "addClass:"],
referencedClasses: []
}),
smalltalk.GlyphIconMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "render:with:",
category: 'rendering',
fn: function (container,html){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(container)._class_(_st(self)._cssClasses());
return self}, function($ctx1) {$ctx1.fill(self,"render:with:",{container:container,html:html},smalltalk.GlyphIconMorph)})},
args: ["container", "html"],
source: "render: container with: html\x0a\x09container\x0a\x09\x09class: self cssClasses.",
messageSends: ["class:", "cssClasses"],
referencedClasses: []
}),
smalltalk.GlyphIconMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "spin",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
$1=self["@spin"];
if(($receiver = $1) == nil || $receiver == undefined){
_st(self)._spin_(false);
} else {
$1;
};
$2=self["@spin"];
return $2;
}, function($ctx1) {$ctx1.fill(self,"spin",{},smalltalk.GlyphIconMorph)})},
args: [],
source: "spin\x0a\x09spin ifNil: [self spin: false].\x0a\x09^ spin",
messageSends: ["ifNil:", "spin:"],
referencedClasses: []
}),
smalltalk.GlyphIconMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "spin:",
category: 'accessing',
fn: function (aBoolean){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
self["@spin"]=aBoolean;
$1=self["@spin"];
if(($receiver = $1) == nil || $receiver == undefined){
$1;
} else {
$2=self["@spin"];
if(smalltalk.assert($2)){
_st(self)._addClass_("icon-spin");
} else {
_st(self)._removeClass_("icon-spin");
};
};
return self}, function($ctx1) {$ctx1.fill(self,"spin:",{aBoolean:aBoolean},smalltalk.GlyphIconMorph)})},
args: ["aBoolean"],
source: "spin: aBoolean\x0a\x09spin := aBoolean.\x0a\x09spin ifNotNil: [\x0a\x09\x09spin\x0a\x09\x09\x09ifTrue: [self addClass: 'icon-spin']\x0a\x09\x09\x09ifFalse: [self removeClass: 'icon-spin']].",
messageSends: ["ifNotNil:", "ifTrue:ifFalse:", "addClass:", "removeClass:"],
referencedClasses: []
}),
smalltalk.GlyphIconMorph);


smalltalk.addMethod(
smalltalk.method({
selector: "edit",
category: 'icons',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._new();
_st($2)._icon_("edit");
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"edit",{},smalltalk.GlyphIconMorph.klass)})},
args: [],
source: "edit\x0a\x09^ self new\x0a\x09\x09icon: 'edit';\x0a\x09\x09yourself",
messageSends: ["icon:", "new", "yourself"],
referencedClasses: []
}),
smalltalk.GlyphIconMorph.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "home",
category: 'icons',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._new();
_st($2)._icon_("home");
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"home",{},smalltalk.GlyphIconMorph.klass)})},
args: [],
source: "home\x0a\x09^ self new\x0a\x09\x09icon: 'home';\x0a\x09\x09yourself",
messageSends: ["icon:", "new", "yourself"],
referencedClasses: []
}),
smalltalk.GlyphIconMorph.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "ok",
category: 'icons',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._new();
_st($2)._icon_("ok");
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"ok",{},smalltalk.GlyphIconMorph.klass)})},
args: [],
source: "ok\x0a\x09^ self new\x0a\x09\x09icon: 'ok';\x0a\x09\x09yourself",
messageSends: ["icon:", "new", "yourself"],
referencedClasses: []
}),
smalltalk.GlyphIconMorph.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "pencil",
category: 'icons',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._new();
_st($2)._icon_("pencil");
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"pencil",{},smalltalk.GlyphIconMorph.klass)})},
args: [],
source: "pencil\x0a\x09^ self new\x0a\x09\x09icon: 'pencil';\x0a\x09\x09yourself",
messageSends: ["icon:", "new", "yourself"],
referencedClasses: []
}),
smalltalk.GlyphIconMorph.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "refresh",
category: 'icons',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._new();
_st($2)._icon_("refresh");
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"refresh",{},smalltalk.GlyphIconMorph.klass)})},
args: [],
source: "refresh\x0a\x09^ self new\x0a\x09\x09icon: 'refresh';\x0a\x09\x09yourself",
messageSends: ["icon:", "new", "yourself"],
referencedClasses: []
}),
smalltalk.GlyphIconMorph.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "remove",
category: 'icons',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._new();
_st($2)._icon_("remove");
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"remove",{},smalltalk.GlyphIconMorph.klass)})},
args: [],
source: "remove\x0a\x09^ self new\x0a\x09\x09icon: 'remove';\x0a\x09\x09yourself",
messageSends: ["icon:", "new", "yourself"],
referencedClasses: []
}),
smalltalk.GlyphIconMorph.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "wait",
category: 'icons',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._new();
_st($2)._icon_("refresh");
_st($2)._spin();
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"wait",{},smalltalk.GlyphIconMorph.klass)})},
args: [],
source: "wait\x0a\x09^ self new\x0a\x09\x09icon: 'refresh';\x0a\x09\x09spin;\x0a\x09\x09yourself",
messageSends: ["icon:", "new", "spin", "yourself"],
referencedClasses: []
}),
smalltalk.GlyphIconMorph.klass);


smalltalk.addClass('LazyListMorph', smalltalk.Morph, ['morphElement', 'entry', 'myIndex', 'content'], 'Canvas');
smalltalk.addMethod(
smalltalk.method({
selector: "content",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@content"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"content",{},smalltalk.LazyListMorph)})},
args: [],
source: "content\x0a\x09^content",
messageSends: [],
referencedClasses: []
}),
smalltalk.LazyListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "content:",
category: 'not yet classified',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@content"]=anObject;
return self}, function($ctx1) {$ctx1.fill(self,"content:",{anObject:anObject},smalltalk.LazyListMorph)})},
args: ["anObject"],
source: "content: anObject\x0a\x09content := anObject",
messageSends: [],
referencedClasses: []
}),
smalltalk.LazyListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "entry",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@entry"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"entry",{},smalltalk.LazyListMorph)})},
args: [],
source: "entry\x0a\x09^entry",
messageSends: [],
referencedClasses: []
}),
smalltalk.LazyListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "index",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@myIndex"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"index",{},smalltalk.LazyListMorph)})},
args: [],
source: "index\x0a\x09^myIndex",
messageSends: [],
referencedClasses: []
}),
smalltalk.LazyListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "index:",
category: 'not yet classified',
fn: function (aNumber){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(aNumber)._isNumber();
if(! smalltalk.assert($1)){
_st(self)._halt();
};
self["@myIndex"]=aNumber;
return self}, function($ctx1) {$ctx1.fill(self,"index:",{aNumber:aNumber},smalltalk.LazyListMorph)})},
args: ["aNumber"],
source: "index: aNumber\x0a\x09aNumber isNumber ifFalse: [self halt].\x0a\x09myIndex := aNumber",
messageSends: ["ifFalse:", "halt", "isNumber"],
referencedClasses: []
}),
smalltalk.LazyListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "renderOn:",
category: 'not yet classified',
fn: function (html){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
self["@entry"]=_st(html)._li_(self["@content"]);
$1=self["@entry"];
_st($1)._addClass_("selectee");
$2=_st($1)._onClick_((function(){
return smalltalk.withContext(function($ctx2) {
_st(self["@entry"])._addClass_("selected");
_st(_st(_st(self["@entry"])._asJQuery())._siblings())._removeClass_("selected");
return _st(self)._selected();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
return self}, function($ctx1) {$ctx1.fill(self,"renderOn:",{html:html},smalltalk.LazyListMorph)})},
args: ["html"],
source: "renderOn: html\x0a\x09entry := html li: content.\x0a\x09\x09entry\x0a\x09\x09\x09addClass: 'selectee';\x0a\x09\x09\x09onClick: [entry addClass: 'selected'. entry asJQuery siblings removeClass: 'selected'.\x0a\x09\x09\x09\x09\x09\x09self selected].",
messageSends: ["li:", "addClass:", "onClick:", "removeClass:", "siblings", "asJQuery", "selected"],
referencedClasses: []
}),
smalltalk.LazyListMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "selected",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._changed_with_("selected:",self);
return self}, function($ctx1) {$ctx1.fill(self,"selected",{},smalltalk.LazyListMorph)})},
args: [],
source: "selected\x0a\x09self changed: #selected: with: self",
messageSends: ["changed:with:"],
referencedClasses: []
}),
smalltalk.LazyListMorph);


smalltalk.addMethod(
smalltalk.method({
selector: "index:dependent:content:",
category: 'not yet classified',
fn: function (anIndex,aDependent,aContent){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._basicNew();
_st($2)._index_(anIndex);
_st($2)._content_(aContent);
_st($2)._addDependent_(aDependent);
_st($2)._owner_(aDependent);
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"index:dependent:content:",{anIndex:anIndex,aDependent:aDependent,aContent:aContent},smalltalk.LazyListMorph.klass)})},
args: ["anIndex", "aDependent", "aContent"],
source: "index: anIndex dependent: aDependent content: aContent\x0a\x09^self basicNew\x0a\x09\x09index: anIndex;\x0a\x09\x09content: aContent;\x0a\x09\x09addDependent: aDependent;\x0a\x09\x09owner: aDependent;\x0a\x09\x09yourself",
messageSends: ["index:", "basicNew", "content:", "addDependent:", "owner:", "yourself"],
referencedClasses: []
}),
smalltalk.LazyListMorph.klass);


smalltalk.addClass('PluggableTextMorph', smalltalk.Morph, ['morphElement', 'textMorph', 'model', 'getTextSelector', 'setTextSelector', 'acceptOnCR'], 'Canvas');
smalltalk.addMethod(
smalltalk.method({
selector: "acceptOnCR",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@acceptOnCR"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"acceptOnCR",{},smalltalk.PluggableTextMorph)})},
args: [],
source: "acceptOnCR\x0a\x09^ acceptOnCR",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "acceptOnCR:",
category: 'accessing',
fn: function (aBoolean){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@acceptOnCR"]=aBoolean;
return self}, function($ctx1) {$ctx1.fill(self,"acceptOnCR:",{aBoolean:aBoolean},smalltalk.PluggableTextMorph)})},
args: ["aBoolean"],
source: "acceptOnCR: aBoolean\x0a\x09acceptOnCR := aBoolean.",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "drawTextMorph",
category: 'rendering',
fn: function (){
var self=this;
function $TextMorph(){return smalltalk.TextMorph||(typeof TextMorph=="undefined"?nil:TextMorph)}
return smalltalk.withContext(function($ctx1) { 
self["@textMorph"]=_st($TextMorph())._new();
_st(self["@textMorph"])._overflowY_("scroll");
_st(self["@textMorph"])._readOnly_(false);
_st(self["@textMorph"])._addDependent_(self);
_st(self)._addMorph_(self["@textMorph"]);
return self}, function($ctx1) {$ctx1.fill(self,"drawTextMorph",{},smalltalk.PluggableTextMorph)})},
args: [],
source: "drawTextMorph\x0a\x09textMorph := TextMorph new.\x0a\x09textMorph overflowY: 'scroll'.\x0a\x09textMorph readOnly: false.\x0a\x09textMorph addDependent: self.\x0a\x09self addMorph: textMorph.",
messageSends: ["new", "overflowY:", "readOnly:", "addDependent:", "addMorph:"],
referencedClasses: ["TextMorph"]
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "getText",
category: 'model access',
fn: function (){
var self=this;
var newText;
function $Text(){return smalltalk.Text||(typeof Text=="undefined"?nil:Text)}
return smalltalk.withContext(function($ctx1) { 
var $1,$2,$3,$4,$5;
$1=self["@getTextSelector"];
if(($receiver = $1) == nil || $receiver == undefined){
$2=_st($Text())._new();
return $2;
} else {
$1;
};
newText=_st(self["@model"])._perform_(self["@getTextSelector"]);
$3=newText;
if(($receiver = $3) == nil || $receiver == undefined){
$4=_st($Text())._new();
return $4;
} else {
$3;
};
$5=_st(newText)._copy();
return $5;
}, function($ctx1) {$ctx1.fill(self,"getText",{newText:newText},smalltalk.PluggableTextMorph)})},
args: [],
source: "getText\x0a\x09| newText |\x0a\x09getTextSelector ifNil: [^Text new].\x0a\x09newText := model perform: getTextSelector.\x0a\x09newText ifNil: [^Text new].\x0a\x09^ newText copy",
messageSends: ["ifNil:", "new", "perform:", "copy"],
referencedClasses: ["Text"]
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "getTextSelector",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@getTextSelector"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"getTextSelector",{},smalltalk.PluggableTextMorph)})},
args: [],
source: "getTextSelector\x0a\x09^ getTextSelector",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "getTextSelector:",
category: 'accessing',
fn: function (aSelector){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@getTextSelector"]=aSelector;
return self}, function($ctx1) {$ctx1.fill(self,"getTextSelector:",{aSelector:aSelector},smalltalk.PluggableTextMorph)})},
args: ["aSelector"],
source: "getTextSelector: aSelector\x0a\x09getTextSelector := aSelector",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "height:",
category: 'geometry',
fn: function (aNumber){
var self=this;
var textHeight;
return smalltalk.withContext(function($ctx1) { 
smalltalk.Morph.fn.prototype._height_.apply(_st(self), [aNumber]);
textHeight=_st(_st(aNumber).__minus(_st((3)).__star(_st(self)._textMorphPadding()))).__minus((1));
_st(_st(self)._textMorph())._height_(textHeight);
return self}, function($ctx1) {$ctx1.fill(self,"height:",{aNumber:aNumber,textHeight:textHeight},smalltalk.PluggableTextMorph)})},
args: ["aNumber"],
source: "height: aNumber\x0a\x09|textHeight|\x0a\x09super height: aNumber.\x0a\x09textHeight := aNumber - (3 * self textMorphPadding) - 1.\x0a\x09self textMorph height: textHeight.",
messageSends: ["height:", "-", "*", "textMorphPadding", "textMorph"],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "keyStroke:",
category: 'events handling',
fn: function (evt){
var self=this;
return smalltalk.withContext(function($ctx1) { 
return self}, function($ctx1) {$ctx1.fill(self,"keyStroke:",{evt:evt},smalltalk.PluggableTextMorph)})},
args: ["evt"],
source: "keyStroke: evt",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "model",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@model"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"model",{},smalltalk.PluggableTextMorph)})},
args: [],
source: "model\x0a\x09^ model",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "model:",
category: 'accessing',
fn: function (aModel){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@model"]=aModel;
return self}, function($ctx1) {$ctx1.fill(self,"model:",{aModel:aModel},smalltalk.PluggableTextMorph)})},
args: ["aModel"],
source: "model: aModel\x0a\x09model := aModel",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "on:text:accept:",
category: 'initialization',
fn: function (anObject,getTextSel,setTextSel){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._model_(anObject);
_st(anObject)._addDependent_(self);
_st(self)._getTextSelector_(getTextSel);
_st(self)._setTextSelector_(setTextSel);
_st(self)._setText_(_st(self)._getText());
return self}, function($ctx1) {$ctx1.fill(self,"on:text:accept:",{anObject:anObject,getTextSel:getTextSel,setTextSel:setTextSel},smalltalk.PluggableTextMorph)})},
args: ["anObject", "getTextSel", "setTextSel"],
source: "on: anObject text: getTextSel accept: setTextSel\x0a\x09self model: anObject.\x0a\x09anObject addDependent: self.\x0a\x09self getTextSelector: getTextSel.\x0a\x09self setTextSelector: setTextSel.\x0a\x09self setText: self getText.",
messageSends: ["model:", "addDependent:", "getTextSelector:", "setTextSelector:", "setText:", "getText"],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "render:with:",
category: 'rendering',
fn: function (container,html){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._drawTextMorph();
return self}, function($ctx1) {$ctx1.fill(self,"render:with:",{container:container,html:html},smalltalk.PluggableTextMorph)})},
args: ["container", "html"],
source: "render: container with: html\x0a\x09self drawTextMorph.",
messageSends: ["drawTextMorph"],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "replaceSelectionWith:",
category: 'updating',
fn: function (aText){
var self=this;
function $Character(){return smalltalk.Character||(typeof Character=="undefined"?nil:Character)}
function $Transcript(){return smalltalk.Transcript||(typeof Transcript=="undefined"?nil:Transcript)}
return smalltalk.withContext(function($ctx1) { 
_st($Transcript())._show_(_st(_st(_st($Character())._cr()).__comma("adding text:")).__comma(aText));
_st(_st(self)._textMorph())._text_(_st(_st(_st(self)._textMorph())._text()).__comma(aText));
return self}, function($ctx1) {$ctx1.fill(self,"replaceSelectionWith:",{aText:aText},smalltalk.PluggableTextMorph)})},
args: ["aText"],
source: "replaceSelectionWith: aText\x0a\x09\x22TODO: implement\x22\x0a\x09Transcript show: Character cr, 'adding text:', aText.\x0a\x09self textMorph text: self textMorph text, aText",
messageSends: ["show:", ",", "cr", "text:", "text", "textMorph"],
referencedClasses: ["Character", "Transcript"]
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "selectFrom:to:",
category: 'interactions',
fn: function (start,stop){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(_st(self)._textMorph())._editor())._selectFrom_to_(start,stop);
return self}, function($ctx1) {$ctx1.fill(self,"selectFrom:to:",{start:start,stop:stop},smalltalk.PluggableTextMorph)})},
args: ["start", "stop"],
source: "selectFrom: start to: stop\x0a\x09self textMorph editor selectFrom: start to: stop.",
messageSends: ["selectFrom:to:", "editor", "textMorph"],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "selectInvisiblyFrom:to:",
category: 'updating',
fn: function (start,stop){
var self=this;
return smalltalk.withContext(function($ctx1) { 
return self}, function($ctx1) {$ctx1.fill(self,"selectInvisiblyFrom:to:",{start:start,stop:stop},smalltalk.PluggableTextMorph)})},
args: ["start", "stop"],
source: "selectInvisiblyFrom: start to: stop\x0a\x09\x22TODO: implement\x22",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "setText:",
category: 'model access',
fn: function (aText){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._textMorph())._newContents_(aText);
return self}, function($ctx1) {$ctx1.fill(self,"setText:",{aText:aText},smalltalk.PluggableTextMorph)})},
args: ["aText"],
source: "setText: aText\x0a\x09self textMorph newContents: aText.",
messageSends: ["newContents:", "textMorph"],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "setTextSelector",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@setTextSelector"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"setTextSelector",{},smalltalk.PluggableTextMorph)})},
args: [],
source: "setTextSelector\x0a\x09^ setTextSelector",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "setTextSelector:",
category: 'accessing',
fn: function (aSelector){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@setTextSelector"]=aSelector;
return self}, function($ctx1) {$ctx1.fill(self,"setTextSelector:",{aSelector:aSelector},smalltalk.PluggableTextMorph)})},
args: ["aSelector"],
source: "setTextSelector: aSelector\x0a\x09setTextSelector := aSelector",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "text",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._textMorph())._contents();
return $1;
}, function($ctx1) {$ctx1.fill(self,"text",{},smalltalk.PluggableTextMorph)})},
args: [],
source: "text\x0a\x09^ self textMorph contents",
messageSends: ["contents", "textMorph"],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "textMorph",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@textMorph"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"textMorph",{},smalltalk.PluggableTextMorph)})},
args: [],
source: "textMorph\x0a\x09^ textMorph",
messageSends: [],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "textMorphClass",
category: 'pharo compatibility',
fn: function (){
var self=this;
function $TextMorphForEditView(){return smalltalk.TextMorphForEditView||(typeof TextMorphForEditView=="undefined"?nil:TextMorphForEditView)}
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=$TextMorphForEditView();
return $1;
}, function($ctx1) {$ctx1.fill(self,"textMorphClass",{},smalltalk.PluggableTextMorph)})},
args: [],
source: "textMorphClass\x0a\x09^ TextMorphForEditView",
messageSends: [],
referencedClasses: ["TextMorphForEditView"]
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "textMorphPadding",
category: 'private',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._textMorph())._padding();
return $1;
}, function($ctx1) {$ctx1.fill(self,"textMorphPadding",{},smalltalk.PluggableTextMorph)})},
args: [],
source: "textMorphPadding\x0a\x09^ self textMorph padding",
messageSends: ["padding", "textMorph"],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "update:",
category: 'updating',
fn: function (aSymbol){
var self=this;
function $Text(){return smalltalk.Text||(typeof Text=="undefined"?nil:Text)}
return smalltalk.withContext(function($ctx1) { 
var $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17;
$1=aSymbol;
if(($receiver = $1) == nil || $receiver == undefined){
$2=self;
return $2;
} else {
$1;
};
$3=_st(aSymbol).__eq_eq("flash");
if(smalltalk.assert($3)){
$4=_st(self)._flash();
return $4;
};
$5=_st(aSymbol).__eq_eq(self["@getTextSelector"]);
if(smalltalk.assert($5)){
_st(self)._setText_(_st(self)._getText());
$6=_st(self)._setSelection_(_st(self)._getSelection());
return $6;
};
$7=_st(aSymbol).__eq_eq("clearUserEdits");
if(smalltalk.assert($7)){
$8=_st(self)._hasUnacceptedEdits_(false);
return $8;
};
$9=_st(aSymbol).__eq_eq("wantToChange");
if(smalltalk.assert($9)){
$10=_st(self)._canDiscardEdits();
if(! smalltalk.assert($10)){
$11=_st(self)._promptForCancel();
return $11;
};
$12=self;
return $12;
};
$13=_st(aSymbol).__eq_eq("appendEntry");
if(smalltalk.assert($13)){
_st(self)._appendEntry();
$14=self;
return $14;
};
$15=_st(aSymbol).__eq_eq("clearText");
if(smalltalk.assert($15)){
_st(self)._handleEdit_((function(){
return smalltalk.withContext(function($ctx2) {
return _st(self)._changeText_(_st($Text())._new());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
$16=self;
return $16;
};
$17=self;
return $17;
}, function($ctx1) {$ctx1.fill(self,"update:",{aSymbol:aSymbol},smalltalk.PluggableTextMorph)})},
args: ["aSymbol"],
source: "update: aSymbol \x0a\x09aSymbol ifNil: [^self].\x0a\x09aSymbol == #flash ifTrue: [^self flash].\x0a\x09aSymbol == getTextSelector \x0a\x09\x09ifTrue: \x0a\x09\x09\x09[self setText: self getText.\x0a\x09\x09\x09^self setSelection: self getSelection].\x0a\x09aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].\x0a\x09aSymbol == #wantToChange \x0a\x09\x09ifTrue: \x0a\x09\x09\x09[self canDiscardEdits ifFalse: [^self promptForCancel].\x0a\x09\x09\x09^self].\x0a\x09aSymbol == #appendEntry \x0a\x09\x09ifTrue: \x0a\x09\x09\x09[self appendEntry.\x0a\x09\x09\x09^self ].\x0a\x09aSymbol == #clearText \x0a\x09\x09ifTrue: \x0a\x09\x09\x09[self handleEdit: [self changeText: Text new].\x0a\x09\x09\x09^self ].\x0a\x09^ self",
messageSends: ["ifNil:", "ifTrue:", "flash", "==", "setText:", "getText", "setSelection:", "getSelection", "hasUnacceptedEdits:", "ifFalse:", "promptForCancel", "canDiscardEdits", "appendEntry", "handleEdit:", "changeText:", "new"],
referencedClasses: ["Text"]
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "update:with:",
category: 'updating',
fn: function (aSymbol,aParameter){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(aSymbol).__eq("keyInput");
if(smalltalk.assert($1)){
_st(self)._keyStroke_(aParameter);
};
return self}, function($ctx1) {$ctx1.fill(self,"update:with:",{aSymbol:aSymbol,aParameter:aParameter},smalltalk.PluggableTextMorph)})},
args: ["aSymbol", "aParameter"],
source: "update: aSymbol with: aParameter\x0a\x09aSymbol = #keyInput \x0a\x09\x09ifTrue: [self keyStroke: aParameter].",
messageSends: ["ifTrue:", "keyStroke:", "="],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "width:",
category: 'geometry',
fn: function (aNumber){
var self=this;
var textWidth;
return smalltalk.withContext(function($ctx1) { 
smalltalk.Morph.fn.prototype._width_.apply(_st(self), [aNumber]);
textWidth=_st(_st(aNumber).__minus(_st((3)).__star(_st(self)._textMorphPadding()))).__minus((1));
_st(_st(self)._textMorph())._width_(textWidth);
return self}, function($ctx1) {$ctx1.fill(self,"width:",{aNumber:aNumber,textWidth:textWidth},smalltalk.PluggableTextMorph)})},
args: ["aNumber"],
source: "width: aNumber\x0a\x09|textWidth|\x0a\x09super width: aNumber.\x0a\x09textWidth := aNumber - (3 * self textMorphPadding) - 1.\x0a\x09self textMorph width: textWidth.",
messageSends: ["width:", "-", "*", "textMorphPadding", "textMorph"],
referencedClasses: []
}),
smalltalk.PluggableTextMorph);


smalltalk.addMethod(
smalltalk.method({
selector: "on:text:accept:",
category: 'instance creation',
fn: function (anObject,getTextSel,setTextSel){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._new())._on_text_accept_(anObject,getTextSel,setTextSel);
return $1;
}, function($ctx1) {$ctx1.fill(self,"on:text:accept:",{anObject:anObject,getTextSel:getTextSel,setTextSel:setTextSel},smalltalk.PluggableTextMorph.klass)})},
args: ["anObject", "getTextSel", "setTextSel"],
source: "on: anObject text: getTextSel accept: setTextSel\x0a\x09^ self new\x0a\x09\x09on: anObject\x0a\x09\x09text: getTextSel\x0a\x09\x09accept: setTextSel",
messageSends: ["on:text:accept:", "new"],
referencedClasses: []
}),
smalltalk.PluggableTextMorph.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "on:text:accept:readSelection:menu:",
category: 'instance creation',
fn: function (anObject,getTextSel,setTextSel,rSel,menu){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._on_text_accept_(anObject,getTextSel,setTextSel);
return $1;
}, function($ctx1) {$ctx1.fill(self,"on:text:accept:readSelection:menu:",{anObject:anObject,getTextSel:getTextSel,setTextSel:setTextSel,rSel:rSel,menu:menu},smalltalk.PluggableTextMorph.klass)})},
args: ["anObject", "getTextSel", "setTextSel", "rSel", "menu"],
source: "on: anObject text: getTextSel accept: setTextSel readSelection: rSel menu: menu\x0a\x09^ self \x0a\x09\x09on: anObject\x0a\x09\x09text: getTextSel\x0a\x09\x09accept: setTextSel",
messageSends: ["on:text:accept:"],
referencedClasses: []
}),
smalltalk.PluggableTextMorph.klass);


smalltalk.addClass('SimpleButtonMorph', smalltalk.Morph, ['morphElement', 'button'], 'Canvas');
smalltalk.addMethod(
smalltalk.method({
selector: "addClass:",
category: 'css',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self["@button"])._asJQuery())._addClass_(aString);
return self}, function($ctx1) {$ctx1.fill(self,"addClass:",{aString:aString},smalltalk.SimpleButtonMorph)})},
args: ["aString"],
source: "addClass: aString\x0a\x09button asJQuery addClass: aString.",
messageSends: ["addClass:", "asJQuery"],
referencedClasses: []
}),
smalltalk.SimpleButtonMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "button",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@button"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"button",{},smalltalk.SimpleButtonMorph)})},
args: [],
source: "button\x0a\x09^ button",
messageSends: [],
referencedClasses: []
}),
smalltalk.SimpleButtonMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "label",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self["@button"])._asJQuery())._html();
return $1;
}, function($ctx1) {$ctx1.fill(self,"label",{},smalltalk.SimpleButtonMorph)})},
args: [],
source: "label\x0a\x09^ button asJQuery html",
messageSends: ["html", "asJQuery"],
referencedClasses: []
}),
smalltalk.SimpleButtonMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "label:",
category: 'accessing',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self["@button"])._with_(aString);
return self}, function($ctx1) {$ctx1.fill(self,"label:",{aString:aString},smalltalk.SimpleButtonMorph)})},
args: ["aString"],
source: "label: aString\x0a\x09button with: aString.",
messageSends: ["with:"],
referencedClasses: []
}),
smalltalk.SimpleButtonMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "onClick:",
category: 'events',
fn: function (aBlock){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self["@button"])._onClick_((function(){
return smalltalk.withContext(function($ctx2) {
return _st(aBlock)._value();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
return self}, function($ctx1) {$ctx1.fill(self,"onClick:",{aBlock:aBlock},smalltalk.SimpleButtonMorph)})},
args: ["aBlock"],
source: "onClick: aBlock\x0a\x09button onClick: [aBlock value].",
messageSends: ["onClick:", "value"],
referencedClasses: []
}),
smalltalk.SimpleButtonMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "render:with:",
category: 'rendering',
fn: function (container,html){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(container)._with_((function(){
return smalltalk.withContext(function($ctx2) {
self["@button"]=_st(_st(html)._a())._class_("btn");
return self["@button"];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
return self}, function($ctx1) {$ctx1.fill(self,"render:with:",{container:container,html:html},smalltalk.SimpleButtonMorph)})},
args: ["container", "html"],
source: "render: container with: html\x0a\x09container  \x0a\x09\x09with: [button := html a class: 'btn'].",
messageSends: ["with:", "class:", "a"],
referencedClasses: []
}),
smalltalk.SimpleButtonMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "submorphContainer",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._button();
return $1;
}, function($ctx1) {$ctx1.fill(self,"submorphContainer",{},smalltalk.SimpleButtonMorph)})},
args: [],
source: "submorphContainer\x0a\x09^ self button",
messageSends: ["button"],
referencedClasses: []
}),
smalltalk.SimpleButtonMorph);



smalltalk.addClass('SystemWindow', smalltalk.Morph, ['morphElement', 'label', 'model', 'morphFrames', 'titlebar'], 'Canvas');
smalltalk.addMethod(
smalltalk.method({
selector: "addMorph:frame:",
category: 'submorphs',
fn: function (aMorph,aRectangle){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._addMorph_(aMorph);
_st(_st(self)._morphFrames())._at_put_(aMorph,aRectangle);
_st(self)._updateLayout();
return self}, function($ctx1) {$ctx1.fill(self,"addMorph:frame:",{aMorph:aMorph,aRectangle:aRectangle},smalltalk.SystemWindow)})},
args: ["aMorph", "aRectangle"],
source: "addMorph: aMorph frame: aRectangle\x0a\x09self addMorph: aMorph.\x0a\x09self morphFrames at: aMorph put: aRectangle.\x0a\x09self updateLayout.",
messageSends: ["addMorph:", "at:put:", "morphFrames", "updateLayout"],
referencedClasses: []
}),
smalltalk.SystemWindow);

smalltalk.addMethod(
smalltalk.method({
selector: "bounds:",
category: 'geometry',
fn: function (aRectangle){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._position_(_st(aRectangle)._origin());
_st(self)._extent_(_st(aRectangle)._extent());
_st(self)._updateLayout();
return self}, function($ctx1) {$ctx1.fill(self,"bounds:",{aRectangle:aRectangle},smalltalk.SystemWindow)})},
args: ["aRectangle"],
source: "bounds: aRectangle\x0a\x09self position: aRectangle origin.\x0a\x09self extent: aRectangle extent.\x0a\x09self updateLayout.",
messageSends: ["position:", "origin", "extent:", "extent", "updateLayout"],
referencedClasses: []
}),
smalltalk.SystemWindow);

smalltalk.addMethod(
smalltalk.method({
selector: "contentExtent",
category: 'geometry',
fn: function (){
var self=this;
function $Point(){return smalltalk.Point||(typeof Point=="undefined"?nil:Point)}
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st($Point())._x_y_(_st(_st(self)._width()).__minus(_st(self)._padding()),_st(_st(_st(_st(self)._height()).__minus(_st(self)._fullTitleBarHeight())).__minus(_st(_st(self)._padding()).__star((3)))).__minus((34)));
return $1;
}, function($ctx1) {$ctx1.fill(self,"contentExtent",{},smalltalk.SystemWindow)})},
args: [],
source: "contentExtent\x0a\x09^ Point\x0a\x09\x09x: self width - self padding\x0a\x09\x09y: self height - self fullTitleBarHeight - (self padding * 3) - 34.",
messageSends: ["x:y:", "-", "padding", "width", "*", "fullTitleBarHeight", "height"],
referencedClasses: ["Point"]
}),
smalltalk.SystemWindow);

smalltalk.addMethod(
smalltalk.method({
selector: "contentOrigin",
category: 'geometry',
fn: function (){
var self=this;
function $Point(){return smalltalk.Point||(typeof Point=="undefined"?nil:Point)}
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st($Point())._x_y_(_st(self)._padding(),_st(_st(self)._fullTitleBarHeight()).__plus(_st(_st(self)._padding()).__star((2))));
return $1;
}, function($ctx1) {$ctx1.fill(self,"contentOrigin",{},smalltalk.SystemWindow)})},
args: [],
source: "contentOrigin\x0a\x09^ Point\x0a\x09\x09x: self padding\x0a\x09\x09y: self fullTitleBarHeight + (self padding * 2)",
messageSends: ["x:y:", "padding", "+", "*", "fullTitleBarHeight"],
referencedClasses: ["Point"]
}),
smalltalk.SystemWindow);

smalltalk.addMethod(
smalltalk.method({
selector: "drawTitleBar",
category: 'rendering',
fn: function (){
var self=this;
function $NavbarMorph(){return smalltalk.NavbarMorph||(typeof NavbarMorph=="undefined"?nil:NavbarMorph)}
function $GlyphIconMorph(){return smalltalk.GlyphIconMorph||(typeof GlyphIconMorph=="undefined"?nil:GlyphIconMorph)}
function $SimpleButtonMorph(){return smalltalk.SimpleButtonMorph||(typeof SimpleButtonMorph=="undefined"?nil:SimpleButtonMorph)}
function $TextMorph(){return smalltalk.TextMorph||(typeof TextMorph=="undefined"?nil:TextMorph)}
return smalltalk.withContext(function($ctx1) { 
var $1,$2,$3,$4,$5,$6;
self["@titlebar"]=_st($NavbarMorph())._new();
_st(self)._addMorph_(self["@titlebar"]);
$1=self["@titlebar"];
_st($1)._adhereToTop();
$2=_st($1)._height_(_st(self)._titleBarHeight());
$3=_st($SimpleButtonMorph())._new();
_st($3)._addMorph_(_st($GlyphIconMorph())._remove());
_st($3)._setToAdhereToEdge_("right");
_st($3)._top_(_st(self["@titlebar"])._padding());
_st($3)._onClick_((function(){
return smalltalk.withContext(function($ctx2) {
return _st(self)._delete();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
$4=_st($3)._yourself();
_st(self["@titlebar"])._addMorph_($4);
$5=_st($TextMorph())._new();
_st($5)._text_("a SystemWindow");
_st($5)._setToAdhereToEdge_("left");
_st($5)._paddingTop_((4));
$6=_st($5)._yourself();
self["@label"]=$6;
_st(self["@titlebar"])._addMorph_(self["@label"]);
return self}, function($ctx1) {$ctx1.fill(self,"drawTitleBar",{},smalltalk.SystemWindow)})},
args: [],
source: "drawTitleBar\x0a\x09titlebar := NavbarMorph new.\x0a\x09self addMorph: titlebar.\x0a\x09titlebar\x0a\x09\x09adhereToTop;\x0a\x09\x09height: self titleBarHeight.\x0a\x09titlebar addMorph: (SimpleButtonMorph new\x0a\x09\x09addMorph: GlyphIconMorph remove;\x0a\x09\x09setToAdhereToEdge: #right;\x0a\x09\x09top: titlebar padding;\x0a\x09\x09onClick: [self delete];\x0a\x09\x09yourself).\x0a\x09titlebar addMorph: (label := TextMorph new\x0a\x09\x09text: 'a SystemWindow';\x0a\x09\x09setToAdhereToEdge: #left;\x0a\x09\x09paddingTop: 4;\x0a\x09\x09yourself).",
messageSends: ["new", "addMorph:", "adhereToTop", "height:", "titleBarHeight", "remove", "setToAdhereToEdge:", "top:", "padding", "onClick:", "delete", "yourself", "text:", "paddingTop:"],
referencedClasses: ["NavbarMorph", "GlyphIconMorph", "SimpleButtonMorph", "TextMorph"]
}),
smalltalk.SystemWindow);

smalltalk.addMethod(
smalltalk.method({
selector: "fullTitleBarHeight",
category: 'constants',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._titleBarHeight()).__plus(_st((2)).__star(_st(self["@titlebar"])._padding()));
return $1;
}, function($ctx1) {$ctx1.fill(self,"fullTitleBarHeight",{},smalltalk.SystemWindow)})},
args: [],
source: "fullTitleBarHeight\x0a\x09^ self titleBarHeight + (2 * titlebar padding)",
messageSends: ["+", "*", "padding", "titleBarHeight"],
referencedClasses: []
}),
smalltalk.SystemWindow);

smalltalk.addMethod(
smalltalk.method({
selector: "isSystemWindow",
category: 'testing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
return true;
}, function($ctx1) {$ctx1.fill(self,"isSystemWindow",{},smalltalk.SystemWindow)})},
args: [],
source: "isSystemWindow\x0a\x09^ true",
messageSends: [],
referencedClasses: []
}),
smalltalk.SystemWindow);

smalltalk.addMethod(
smalltalk.method({
selector: "label",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st(self)._labelMorph())._text();
return $1;
}, function($ctx1) {$ctx1.fill(self,"label",{},smalltalk.SystemWindow)})},
args: [],
source: "label\x0a\x09^ self labelMorph text",
messageSends: ["text", "labelMorph"],
referencedClasses: []
}),
smalltalk.SystemWindow);

smalltalk.addMethod(
smalltalk.method({
selector: "labelMorph",
category: 'private',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@label"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"labelMorph",{},smalltalk.SystemWindow)})},
args: [],
source: "labelMorph\x0a\x09^ label",
messageSends: [],
referencedClasses: []
}),
smalltalk.SystemWindow);

smalltalk.addMethod(
smalltalk.method({
selector: "model:",
category: 'accessing',
fn: function (aModel){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@model"]=aModel;
return self}, function($ctx1) {$ctx1.fill(self,"model:",{aModel:aModel},smalltalk.SystemWindow)})},
args: ["aModel"],
source: "model: aModel\x0a\x09model := aModel.",
messageSends: [],
referencedClasses: []
}),
smalltalk.SystemWindow);

smalltalk.addMethod(
smalltalk.method({
selector: "morphFrames",
category: 'private',
fn: function (){
var self=this;
function $Dictionary(){return smalltalk.Dictionary||(typeof Dictionary=="undefined"?nil:Dictionary)}
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
$1=self["@morphFrames"];
if(($receiver = $1) == nil || $receiver == undefined){
self["@morphFrames"]=_st($Dictionary())._new();
self["@morphFrames"];
} else {
$1;
};
$2=self["@morphFrames"];
return $2;
}, function($ctx1) {$ctx1.fill(self,"morphFrames",{},smalltalk.SystemWindow)})},
args: [],
source: "morphFrames\x0a\x09morphFrames ifNil: [morphFrames := Dictionary new].\x0a\x09^ morphFrames",
messageSends: ["ifNil:", "new"],
referencedClasses: ["Dictionary"]
}),
smalltalk.SystemWindow);

smalltalk.addMethod(
smalltalk.method({
selector: "openInWorld",
category: 'display',
fn: function (){
var self=this;
function $WorkspaceMorph(){return smalltalk.WorkspaceMorph||(typeof WorkspaceMorph=="undefined"?nil:WorkspaceMorph)}
return smalltalk.withContext(function($ctx1) { 
_st(_st($WorkspaceMorph())._current())._addMorph_(self);
return self}, function($ctx1) {$ctx1.fill(self,"openInWorld",{},smalltalk.SystemWindow)})},
args: [],
source: "openInWorld\x0a\x09WorkspaceMorph current addMorph: self",
messageSends: ["addMorph:", "current"],
referencedClasses: ["WorkspaceMorph"]
}),
smalltalk.SystemWindow);

smalltalk.addMethod(
smalltalk.method({
selector: "render:with:",
category: 'rendering',
fn: function (container,html){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
$1=container;
_st($1)._class_("component window");
_st($1)._draggable();
_st($1)._resizable();
$2=_st($1)._onResize_((function(){
return smalltalk.withContext(function($ctx2) {
return _st(self)._updateLayout();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
_st(self)._setDefaultSize();
_st(self)._drawTitleBar();
return self}, function($ctx1) {$ctx1.fill(self,"render:with:",{container:container,html:html},smalltalk.SystemWindow)})},
args: ["container", "html"],
source: "render: container with: html\x0a\x09container  \x0a\x09\x09class: 'component window';\x0a\x09\x09draggable;\x0a\x09\x09resizable;\x0a\x09\x09onResize: [self updateLayout].\x0a\x09self setDefaultSize.\x0a\x09self drawTitleBar.",
messageSends: ["class:", "draggable", "resizable", "onResize:", "updateLayout", "setDefaultSize", "drawTitleBar"],
referencedClasses: []
}),
smalltalk.SystemWindow);

smalltalk.addMethod(
smalltalk.method({
selector: "setDefaultSize",
category: 'rendering',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(self)._height_((250));
_st(self)._width_((250));
return self}, function($ctx1) {$ctx1.fill(self,"setDefaultSize",{},smalltalk.SystemWindow)})},
args: [],
source: "setDefaultSize\x0a\x09self height: 250.\x0a\x09self width: 250.",
messageSends: ["height:", "width:"],
referencedClasses: []
}),
smalltalk.SystemWindow);

smalltalk.addMethod(
smalltalk.method({
selector: "setLabel:",
category: 'accessing',
fn: function (aString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(_st(self)._labelMorph())._text_(aString);
return self}, function($ctx1) {$ctx1.fill(self,"setLabel:",{aString:aString},smalltalk.SystemWindow)})},
args: ["aString"],
source: "setLabel: aString\x0a\x09self labelMorph text: aString.",
messageSends: ["text:", "labelMorph"],
referencedClasses: []
}),
smalltalk.SystemWindow);

smalltalk.addMethod(
smalltalk.method({
selector: "titleBarHeight",
category: 'constants',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=(30);
return $1;
}, function($ctx1) {$ctx1.fill(self,"titleBarHeight",{},smalltalk.SystemWindow)})},
args: [],
source: "titleBarHeight\x0a\x09^ 30",
messageSends: [],
referencedClasses: []
}),
smalltalk.SystemWindow);

smalltalk.addMethod(
smalltalk.method({
selector: "titlebar",
category: 'private',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@titlebar"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"titlebar",{},smalltalk.SystemWindow)})},
args: [],
source: "titlebar\x0a\x09^ titlebar",
messageSends: [],
referencedClasses: []
}),
smalltalk.SystemWindow);

smalltalk.addMethod(
smalltalk.method({
selector: "updateLayout",
category: 'geometry',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
smalltalk.Morph.fn.prototype._updateLayout.apply(_st(self), []);
_st(_st(self)._morphFrames())._keysAndValuesDo_((function(morph,frame){
return smalltalk.withContext(function($ctx2) {
$1=morph;
_st($1)._positionAbsolute();
_st($1)._position_(_st(_st(_st(frame)._origin()).__star(_st(self)._contentExtent())).__plus(_st(self)._contentOrigin()));
$2=_st($1)._extent_(_st(_st(_st(frame)._corner()).__star(_st(self)._contentExtent())).__plus(_st(self)._contentOrigin()));
return $2;
}, function($ctx2) {$ctx2.fillBlock({morph:morph,frame:frame},$ctx1)})}));
return self}, function($ctx1) {$ctx1.fill(self,"updateLayout",{},smalltalk.SystemWindow)})},
args: [],
source: "updateLayout\x0a\x09super updateLayout.\x0a\x09self morphFrames keysAndValuesDo: [:morph :frame | \x0a\x09\x09morph\x0a\x09\x09\x09positionAbsolute;\x0a\x09\x09\x09position: frame origin * self contentExtent + self contentOrigin;\x0a\x09\x09\x09extent: frame corner * self contentExtent + self contentOrigin].",
messageSends: ["updateLayout", "keysAndValuesDo:", "positionAbsolute", "position:", "+", "contentOrigin", "*", "contentExtent", "origin", "extent:", "corner", "morphFrames"],
referencedClasses: []
}),
smalltalk.SystemWindow);


smalltalk.addMethod(
smalltalk.method({
selector: "labelled:",
category: 'instance creation',
fn: function (labelString){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._new();
_st($2)._setLabel_(labelString);
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"labelled:",{labelString:labelString},smalltalk.SystemWindow.klass)})},
args: ["labelString"],
source: "labelled: labelString\x0a\x09^ self new \x0a\x09\x09setLabel: labelString;\x0a\x09\x09yourself",
messageSends: ["setLabel:", "new", "yourself"],
referencedClasses: []
}),
smalltalk.SystemWindow.klass);


smalltalk.addClass('UIManager', smalltalk.Morph, ['morphElement', 'question', 'yesAnswer', 'noAnswer', 'cancelAnswer', 'yesButton', 'noButton', 'cancelButton', 'answer', 'questionDiv', 'morphOffsets', 'systemWindow'], 'Canvas');
smalltalk.addMethod(
smalltalk.method({
selector: "answer",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@answer"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"answer",{},smalltalk.UIManager)})},
args: [],
source: "answer\x0a\x09^answer",
messageSends: [],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "answer:",
category: 'accessing',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@answer"]=anObject;
return self}, function($ctx1) {$ctx1.fill(self,"answer:",{anObject:anObject},smalltalk.UIManager)})},
args: ["anObject"],
source: "answer: anObject\x0a\x09answer := anObject",
messageSends: [],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "cancelAnswer",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@cancelAnswer"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"cancelAnswer",{},smalltalk.UIManager)})},
args: [],
source: "cancelAnswer\x0a\x09^cancelAnswer",
messageSends: [],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "cancelAnswer:",
category: 'accessing',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@cancelAnswer"]=anObject;
return self}, function($ctx1) {$ctx1.fill(self,"cancelAnswer:",{anObject:anObject},smalltalk.UIManager)})},
args: ["anObject"],
source: "cancelAnswer: anObject\x0a\x09cancelAnswer := anObject",
messageSends: [],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "cancelButton",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@cancelButton"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"cancelButton",{},smalltalk.UIManager)})},
args: [],
source: "cancelButton\x0a\x09^cancelButton",
messageSends: [],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "cancelButton:",
category: 'accessing',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@cancelButton"]=anObject;
return self}, function($ctx1) {$ctx1.fill(self,"cancelButton:",{anObject:anObject},smalltalk.UIManager)})},
args: ["anObject"],
source: "cancelButton: anObject\x0a\x09cancelButton := anObject",
messageSends: [],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "confirm:trueChoice:falseChoice:cancelChoice:default:",
category: 'not yet classified',
fn: function (queryString,yes,no,cancelChoice,defaultOption){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=self;
_st($2)._question_(queryString);
_st($2)._yesAnswer_(yes);
_st($2)._noAnswer_(no);
_st($2)._cancelAnswer_(cancelChoice);
_st($2)._update();
$3=_st($2)._answer();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"confirm:trueChoice:falseChoice:cancelChoice:default:",{queryString:queryString,yes:yes,no:no,cancelChoice:cancelChoice,defaultOption:defaultOption},smalltalk.UIManager)})},
args: ["queryString", "yes", "no", "cancelChoice", "defaultOption"],
source: "confirm: queryString trueChoice: yes falseChoice: no cancelChoice: cancelChoice default: defaultOption\x0a\x09^self \x0a\x09\x09question: queryString;\x0a\x09\x09yesAnswer: yes;\x0a\x09\x09noAnswer: no;\x0a\x09\x09cancelAnswer: cancelChoice;\x0a\x09\x09update;\x0a\x09\x09answer",
messageSends: ["question:", "yesAnswer:", "noAnswer:", "cancelAnswer:", "update", "answer"],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "contentExtent",
category: 'geometry',
fn: function (){
var self=this;
function $Point(){return smalltalk.Point||(typeof Point=="undefined"?nil:Point)}
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st($Point())._x_y_(_st(_st(self)._width()).__minus(_st(self)._padding()),_st(_st(self)._height()).__minus(_st(self)._padding()));
return $1;
}, function($ctx1) {$ctx1.fill(self,"contentExtent",{},smalltalk.UIManager)})},
args: [],
source: "contentExtent\x0a\x09^ Point\x0a\x09\x09x: self width - self padding\x0a\x09\x09y: self height - self padding.",
messageSends: ["x:y:", "-", "padding", "width", "height"],
referencedClasses: ["Point"]
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "contentOrigin",
category: 'geometry',
fn: function (){
var self=this;
function $Point(){return smalltalk.Point||(typeof Point=="undefined"?nil:Point)}
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st($Point())._x_y_(_st(self)._padding(),_st(self)._padding());
return $1;
}, function($ctx1) {$ctx1.fill(self,"contentOrigin",{},smalltalk.UIManager)})},
args: [],
source: "contentOrigin\x0a\x09^ Point\x0a\x09\x09x: self padding\x0a\x09\x09y: self padding",
messageSends: ["x:y:", "padding"],
referencedClasses: ["Point"]
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "drawButtons",
category: 'rendering',
fn: function (){
var self=this;
function $SimpleButtonMorph(){return smalltalk.SimpleButtonMorph||(typeof SimpleButtonMorph=="undefined"?nil:SimpleButtonMorph)}
return smalltalk.withContext(function($ctx1) { 
var $1,$2,$3,$4,$5,$7,$8,$6,$9,$10;
$1=self;
$2=_st($SimpleButtonMorph())._new();
_st($2)._setToAdhereToEdge_("bottom");
_st($2)._label_(_st(self)._yesAnswer());
$3=_st($2)._onClick_((function(){
return smalltalk.withContext(function($ctx2) {
_st(self)._answer_(true);
return _st(self["@systemWindow"])._delete();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
_st($1)._yesButton_($3);
$4=_st($SimpleButtonMorph())._new();
_st($4)._setToAdhereToEdge_("bottom");
_st($4)._label_(_st(self)._noAnswer());
$5=_st($4)._onClick_((function(){
return smalltalk.withContext(function($ctx2) {
_st(self)._answer_(false);
return _st(self["@systemWindow"])._delete();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
_st($1)._noButton_($5);
$7=_st($SimpleButtonMorph())._new();
_st($7)._setToAdhereToEdge_("bottom");
_st($7)._label_(_st(self)._cancelAnswer());
$8=_st($7)._onClick_((function(){
return smalltalk.withContext(function($ctx2) {
_st(self)._answer_(nil);
return _st(self["@systemWindow"])._delete();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
$6=_st($1)._cancelButton_($8);
$9=self;
_st($9)._addMorph_(_st(self)._yesButton());
_st($9)._addMorph_(_st(self)._noButton());
$10=_st($9)._addMorph_(_st(self)._cancelButton());
return self}, function($ctx1) {$ctx1.fill(self,"drawButtons",{},smalltalk.UIManager)})},
args: [],
source: "drawButtons\x0a\x09self \x0a\x09\x09yesButton: (SimpleButtonMorph new \x0a\x09\x09\x09\x09\x09\x09\x09setToAdhereToEdge: #bottom;\x0a\x09\x09\x09\x09\x09\x09\x09label: self yesAnswer;\x0a\x09\x09\x09\x09\x09\x09\x09onClick:[ self answer: true. systemWindow delete]);\x0a\x09\x09noButton: (SimpleButtonMorph new \x0a\x09\x09\x09\x09\x09\x09\x09setToAdhereToEdge: #bottom;\x0a\x09\x09\x09\x09\x09\x09\x09label: self noAnswer;\x0a\x09\x09\x09\x09\x09\x09\x09onClick:[ self answer: false. systemWindow delete]);\x0a\x09\x09cancelButton: (SimpleButtonMorph new \x0a\x09\x09\x09\x09\x09\x09\x09setToAdhereToEdge: #bottom;\x0a\x09\x09\x09\x09\x09\x09\x09label: self cancelAnswer;\x0a\x09\x09\x09\x09\x09\x09\x09onClick:[ self answer: nil. systemWindow delete]).\x0a\x09self \x0a\x09\x09addMorph: self yesButton;\x0a\x09\x09addMorph: self noButton;\x0a\x09\x09addMorph: self cancelButton.",
messageSends: ["yesButton:", "setToAdhereToEdge:", "new", "label:", "yesAnswer", "onClick:", "answer:", "delete", "noButton:", "noAnswer", "cancelButton:", "cancelAnswer", "addMorph:", "yesButton", "noButton", "cancelButton"],
referencedClasses: ["SimpleButtonMorph"]
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "initialize",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
$1=self;
_st($1)._yesAnswer_("Yes");
_st($1)._noAnswer_("No");
$2=_st($1)._cancelAnswer_("Cancel");
self["@notClosed"]=true;
smalltalk.Morph.fn.prototype._initialize.apply(_st(self), []);
return self}, function($ctx1) {$ctx1.fill(self,"initialize",{},smalltalk.UIManager)})},
args: [],
source: "initialize\x0a\x09self \x0a\x09\x09yesAnswer: 'Yes';\x0a\x09\x09noAnswer: 'No';\x0a\x09\x09cancelAnswer: 'Cancel'.\x0a\x09notClosed:= true.\x0a\x09super initialize\x0a\x09",
messageSends: ["yesAnswer:", "noAnswer:", "cancelAnswer:", "initialize"],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "morphOffsets",
category: 'accessing',
fn: function (){
var self=this;
function $Dictionary(){return smalltalk.Dictionary||(typeof Dictionary=="undefined"?nil:Dictionary)}
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
$1=self["@morphOffsets"];
if(($receiver = $1) == nil || $receiver == undefined){
self["@morphOffsets"]=_st($Dictionary())._new();
self["@morphOffsets"];
} else {
$1;
};
$2=self["@morphOffsets"];
return $2;
}, function($ctx1) {$ctx1.fill(self,"morphOffsets",{},smalltalk.UIManager)})},
args: [],
source: "morphOffsets\x0a\x09morphOffsets ifNil: [morphOffsets := Dictionary new].\x0a\x09^ morphOffsets",
messageSends: ["ifNil:", "new"],
referencedClasses: ["Dictionary"]
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "noAnswer",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@noAnswer"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"noAnswer",{},smalltalk.UIManager)})},
args: [],
source: "noAnswer\x0a\x09^noAnswer",
messageSends: [],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "noAnswer:",
category: 'accessing',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@noAnswer"]=anObject;
return self}, function($ctx1) {$ctx1.fill(self,"noAnswer:",{anObject:anObject},smalltalk.UIManager)})},
args: ["anObject"],
source: "noAnswer: anObject\x0a\x09noAnswer := anObject",
messageSends: [],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "noButton",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@noButton"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"noButton",{},smalltalk.UIManager)})},
args: [],
source: "noButton\x0a\x09^noButton",
messageSends: [],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "noButton:",
category: 'accessing',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@noButton"]=anObject;
return self}, function($ctx1) {$ctx1.fill(self,"noButton:",{anObject:anObject},smalltalk.UIManager)})},
args: ["anObject"],
source: "noButton: anObject\x0a\x09noButton := anObject",
messageSends: [],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "openInWorld",
category: 'rendering',
fn: function (){
var self=this;
var win;
function $SystemWindow(){return smalltalk.SystemWindow||(typeof SystemWindow=="undefined"?nil:SystemWindow)}
function $WorkspaceMorph(){return smalltalk.WorkspaceMorph||(typeof WorkspaceMorph=="undefined"?nil:WorkspaceMorph)}
return smalltalk.withContext(function($ctx1) { 
self["@systemWindow"]=_st($SystemWindow())._labelled_("Question");
_st(_st($WorkspaceMorph())._current())._addMorph_(self["@systemWindow"]);
_st(self["@systemWindow"])._addMorph_frame_(self,_st(_st((0)).__at((0)))._extent_(_st((1)).__at((1))));
return self}, function($ctx1) {$ctx1.fill(self,"openInWorld",{win:win},smalltalk.UIManager)})},
args: [],
source: "openInWorld\x0a\x09|win|\x0a\x09systemWindow := SystemWindow labelled:'Question'.\x0a\x09WorkspaceMorph current addMorph:systemWindow.\x0a\x09systemWindow addMorph: self frame: (0@0 extent: 1@1)",
messageSends: ["labelled:", "addMorph:", "current", "addMorph:frame:", "extent:", "@"],
referencedClasses: ["SystemWindow", "WorkspaceMorph"]
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "question",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@question"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"question",{},smalltalk.UIManager)})},
args: [],
source: "question\x0a\x09^question",
messageSends: [],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "question:",
category: 'accessing',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@question"]=anObject;
return self}, function($ctx1) {$ctx1.fill(self,"question:",{anObject:anObject},smalltalk.UIManager)})},
args: ["anObject"],
source: "question: anObject\x0a\x09question := anObject",
messageSends: [],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "render:with:",
category: 'rendering',
fn: function (container,html){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(container)._with_((function(){
return smalltalk.withContext(function($ctx2) {
self["@questionDiv"]=_st(html)._div_(_st(self)._question());
return self["@questionDiv"];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
_st(self)._drawButtons();
return self}, function($ctx1) {$ctx1.fill(self,"render:with:",{container:container,html:html},smalltalk.UIManager)})},
args: ["container", "html"],
source: "render: container with: html\x0a\x09container with:\x0a\x09\x09[questionDiv := html div: self question].\x0a\x09self drawButtons",
messageSends: ["with:", "div:", "question", "drawButtons"],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "update",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
$1=self["@questionDiv"];
_st($1)._empty();
$2=_st($1)._with_(_st(self)._question());
_st(_st(_st(self)._yesButton())._button())._empty();
_st(_st(self)._yesButton())._label_(_st(self)._yesAnswer());
_st(_st(_st(self)._noButton())._button())._empty();
_st(_st(self)._noButton())._label_(_st(self)._noAnswer());
_st(_st(_st(self)._cancelButton())._button())._empty();
_st(_st(self)._cancelButton())._label_(_st(self)._cancelAnswer());
return self}, function($ctx1) {$ctx1.fill(self,"update",{},smalltalk.UIManager)})},
args: [],
source: "update\x0a\x0a\x09questionDiv empty;\x0a\x09\x09\x09with: self question.\x09 \x0a\x09self yesButton button empty.\x0a\x09self yesButton label: self yesAnswer.\x0a\x09self noButton button empty.\x0a\x09self noButton label: self noAnswer.\x0a\x09self cancelButton button empty.\x0a\x09self cancelButton label: self cancelAnswer.\x0a\x09",
messageSends: ["empty", "with:", "question", "button", "yesButton", "label:", "yesAnswer", "noButton", "noAnswer", "cancelButton", "cancelAnswer"],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "updateLayout",
category: 'geometry',
fn: function (){
var self=this;
var width;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
smalltalk.Morph.fn.prototype._updateLayout.apply(_st(self), []);
width=(0);
_st(self)._submorphsDo_((function(morph){
return smalltalk.withContext(function($ctx2) {
$1=morph;
_st($1)._positionAbsolute();
$2=_st($1)._left_(width);
$2;
width=_st(_st(_st(width).__plus(_st(morph)._width())).__plus(_st(morph)._padding())).__plus((3));
return width;
}, function($ctx2) {$ctx2.fillBlock({morph:morph},$ctx1)})}));
_st(self["@systemWindow"])._extent_(_st(_st(width).__plus(_st(self["@systemWindow"])._padding())).__at(_st(_st(_st(_st(_st(self)._yesButton())._height()).__plus(_st(_st(self["@questionDiv"])._asJQuery())._height())).__star((1.5))).__plus(_st(self["@systemWindow"])._fullTitleBarHeight())));
return self}, function($ctx1) {$ctx1.fill(self,"updateLayout",{width:width},smalltalk.UIManager)})},
args: [],
source: "updateLayout\x0a\x09|width|\x0a\x09super updateLayout.\x0a\x09width := 0.\x0a\x09self submorphsDo: [:morph  | \x0a\x09\x09morph\x0a\x09\x09\x09positionAbsolute;\x0a\x09\x09\x09left: width.\x0a\x09\x09width := width + morph width + morph padding + 3].\x0a\x09systemWindow extent: (width + systemWindow padding)@(self yesButton height + questionDiv asJQuery height * 1.5 + systemWindow fullTitleBarHeight)\x0a\x09",
messageSends: ["updateLayout", "submorphsDo:", "positionAbsolute", "left:", "+", "padding", "width", "extent:", "@", "fullTitleBarHeight", "*", "height", "asJQuery", "yesButton"],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "yesAnswer",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@yesAnswer"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"yesAnswer",{},smalltalk.UIManager)})},
args: [],
source: "yesAnswer\x0a\x09^yesAnswer",
messageSends: [],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "yesAnswer:",
category: 'accessing',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@yesAnswer"]=anObject;
return self}, function($ctx1) {$ctx1.fill(self,"yesAnswer:",{anObject:anObject},smalltalk.UIManager)})},
args: ["anObject"],
source: "yesAnswer: anObject\x0a\x09yesAnswer := anObject",
messageSends: [],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "yesButton",
category: 'accessing',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=self["@yesButton"];
return $1;
}, function($ctx1) {$ctx1.fill(self,"yesButton",{},smalltalk.UIManager)})},
args: [],
source: "yesButton\x0a\x09^yesButton",
messageSends: [],
referencedClasses: []
}),
smalltalk.UIManager);

smalltalk.addMethod(
smalltalk.method({
selector: "yesButton:",
category: 'accessing',
fn: function (anObject){
var self=this;
return smalltalk.withContext(function($ctx1) { 
self["@yesButton"]=anObject;
return self}, function($ctx1) {$ctx1.fill(self,"yesButton:",{anObject:anObject},smalltalk.UIManager)})},
args: ["anObject"],
source: "yesButton: anObject\x0a\x09yesButton:= anObject",
messageSends: [],
referencedClasses: []
}),
smalltalk.UIManager);


smalltalk.addMethod(
smalltalk.method({
selector: "default",
category: 'not yet classified',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(self)._new();
return $1;
}, function($ctx1) {$ctx1.fill(self,"default",{},smalltalk.UIManager.klass)})},
args: [],
source: "default\x0a\x09^self new",
messageSends: ["new"],
referencedClasses: []
}),
smalltalk.UIManager.klass);


smalltalk.addClass('WorkspaceMorph', smalltalk.Morph, ['morphElement'], 'Canvas');
smalltalk.addMethod(
smalltalk.method({
selector: "addMorph:",
category: 'submorphs',
fn: function (aMorph){
var self=this;
return smalltalk.withContext(function($ctx1) { 
smalltalk.Morph.fn.prototype._addMorph_.apply(_st(self), [aMorph]);
_st(_st(aMorph)._morphElement())._onMouseDown_((function(){
return smalltalk.withContext(function($ctx2) {
return _st(self)._moveToFront_(aMorph);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1)})}));
return self}, function($ctx1) {$ctx1.fill(self,"addMorph:",{aMorph:aMorph},smalltalk.WorkspaceMorph)})},
args: ["aMorph"],
source: "addMorph: aMorph\x0a\x09super addMorph: aMorph.\x0a\x09aMorph morphElement onMouseDown: [self moveToFront: aMorph].",
messageSends: ["addMorph:", "onMouseDown:", "moveToFront:", "morphElement"],
referencedClasses: []
}),
smalltalk.WorkspaceMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "moveToFront:",
category: 'geometry',
fn: function (aMorph){
var self=this;
var zMax,zMin;
return smalltalk.withContext(function($ctx1) { 
var $1;
zMin=_st(_st(_st(self)._submorphs())._collect_((function(morph){
return smalltalk.withContext(function($ctx2) {
return _st(morph)._zIndex();
}, function($ctx2) {$ctx2.fillBlock({morph:morph},$ctx1)})})))._min();
$1=_st(zMin).__gt((0));
if(smalltalk.assert($1)){
_st(_st(self)._submorphs())._do_((function(morph){
return smalltalk.withContext(function($ctx2) {
return _st(morph)._zIndex_(_st(_st(morph)._zIndex()).__minus(zMin));
}, function($ctx2) {$ctx2.fillBlock({morph:morph},$ctx1)})}));
};
zMax=_st(_st(_st(self)._submorphs())._collect_((function(morph){
return smalltalk.withContext(function($ctx2) {
return _st(morph)._zIndex();
}, function($ctx2) {$ctx2.fillBlock({morph:morph},$ctx1)})})))._max();
_st(aMorph)._zIndex_(_st(zMax).__plus((1)));
return self}, function($ctx1) {$ctx1.fill(self,"moveToFront:",{aMorph:aMorph,zMax:zMax,zMin:zMin},smalltalk.WorkspaceMorph)})},
args: ["aMorph"],
source: "moveToFront: aMorph\x0a\x09|zMax zMin|\x0a\x09zMin := (self submorphs collect: [:morph | morph zIndex]) min.\x0a\x09zMin > 0 ifTrue: [\x0a\x09\x09self submorphs do: [:morph | morph zIndex: morph zIndex - zMin]].\x0a\x09zMax := (self submorphs collect: [:morph | morph zIndex]) max.\x0a\x09aMorph zIndex: zMax + 1.",
messageSends: ["min", "collect:", "zIndex", "submorphs", "ifTrue:", "do:", "zIndex:", "-", ">", "max", "+"],
referencedClasses: []
}),
smalltalk.WorkspaceMorph);

smalltalk.addMethod(
smalltalk.method({
selector: "render:with:",
category: 'rendering',
fn: function (container,html){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(container)._id_("workspace");
return self}, function($ctx1) {$ctx1.fill(self,"render:with:",{container:container,html:html},smalltalk.WorkspaceMorph)})},
args: ["container", "html"],
source: "render: container with: html\x0a\x09container\x0a\x09\x09id: 'workspace'.",
messageSends: ["id:"],
referencedClasses: []
}),
smalltalk.WorkspaceMorph);


smalltalk.WorkspaceMorph.klass.iVarNames = ['workspace'];
smalltalk.addMethod(
smalltalk.method({
selector: "canvas:",
category: 'instance creation',
fn: function (aCanvas){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._basicNew();
_st($2)._initialize();
_st($2)._initializeFromString_canvas_("div",aCanvas);
$3=_st($2)._yourself();
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"canvas:",{aCanvas:aCanvas},smalltalk.WorkspaceMorph.klass)})},
args: ["aCanvas"],
source: "canvas: aCanvas\x0a\x09^ self basicNew\x0a\x09initialize;\x0a\x09initializeFromString: 'div' canvas: aCanvas;\x0a\x09yourself",
messageSends: ["initialize", "basicNew", "initializeFromString:canvas:", "yourself"],
referencedClasses: []
}),
smalltalk.WorkspaceMorph.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "containerRoot",
category: 'instance creation',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st("body")._asJQuery();
return $1;
}, function($ctx1) {$ctx1.fill(self,"containerRoot",{},smalltalk.WorkspaceMorph.klass)})},
args: [],
source: "containerRoot\x0a\x09^ 'body' asJQuery",
messageSends: ["asJQuery"],
referencedClasses: []
}),
smalltalk.WorkspaceMorph.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "current",
category: 'singleton',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $1,$2;
$1=self["@workspace"];
if(($receiver = $1) == nil || $receiver == undefined){
self["@workspace"]=_st(self)._privateNew();
self["@workspace"];
} else {
$1;
};
$2=self["@workspace"];
return $2;
}, function($ctx1) {$ctx1.fill(self,"current",{},smalltalk.WorkspaceMorph.klass)})},
args: [],
source: "current\x0a\x09workspace ifNil: [workspace := self privateNew].\x0a\x09^ workspace",
messageSends: ["ifNil:", "privateNew"],
referencedClasses: []
}),
smalltalk.WorkspaceMorph.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "new",
category: 'instance creation',
fn: function (){
var self=this;
function $Error(){return smalltalk.Error||(typeof Error=="undefined"?nil:Error)}
return smalltalk.withContext(function($ctx1) { 
_st($Error())._signal_("#new not allowed for singleton");
return self}, function($ctx1) {$ctx1.fill(self,"new",{},smalltalk.WorkspaceMorph.klass)})},
args: [],
source: "new\x0a\x09Error signal: '#new not allowed for singleton'",
messageSends: ["signal:"],
referencedClasses: ["Error"]
}),
smalltalk.WorkspaceMorph.klass);

smalltalk.addMethod(
smalltalk.method({
selector: "privateNew",
category: 'instance creation',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
var $2,$3,$1;
$2=_st(self)._basicNew();
_st($2)._initialize();
$3=_st($2)._appendToJQuery_(_st(self)._containerRoot());
$1=$3;
return $1;
}, function($ctx1) {$ctx1.fill(self,"privateNew",{},smalltalk.WorkspaceMorph.klass)})},
args: [],
source: "privateNew\x0a\x09^ self basicNew\x0a\x09\x09\x09initialize;\x0a\x09\x09\x09appendToJQuery: self containerRoot",
messageSends: ["initialize", "basicNew", "appendToJQuery:", "containerRoot"],
referencedClasses: []
}),
smalltalk.WorkspaceMorph.klass);


smalltalk.addMethod(
smalltalk.method({
selector: "appendToBrush:",
category: '*Canvas',
fn: function (aTagBrush){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(aTagBrush)._append_(_st(self)._asString());
return self}, function($ctx1) {$ctx1.fill(self,"appendToBrush:",{aTagBrush:aTagBrush},smalltalk.Object)})},
args: ["aTagBrush"],
source: "appendToBrush: aTagBrush\x0a\x09aTagBrush append: self asString",
messageSends: ["append:", "asString"],
referencedClasses: []
}),
smalltalk.Object);

smalltalk.addMethod(
smalltalk.method({
selector: "appendToJQuery:",
category: '*Canvas',
fn: function (aJQuery){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(aJQuery)._append_(_st(self)._asString());
return self}, function($ctx1) {$ctx1.fill(self,"appendToJQuery:",{aJQuery:aJQuery},smalltalk.Object)})},
args: ["aJQuery"],
source: "appendToJQuery: aJQuery\x0a\x09aJQuery append: self asString",
messageSends: ["append:", "asString"],
referencedClasses: []
}),
smalltalk.Object);

smalltalk.addMethod(
smalltalk.method({
selector: "appendToBrush:",
category: '*Canvas',
fn: function (aTagBrush){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(aTagBrush)._appendBlock_(self);
return self}, function($ctx1) {$ctx1.fill(self,"appendToBrush:",{aTagBrush:aTagBrush},smalltalk.BlockClosure)})},
args: ["aTagBrush"],
source: "appendToBrush: aTagBrush\x0a\x09aTagBrush appendBlock: self",
messageSends: ["appendBlock:"],
referencedClasses: []
}),
smalltalk.BlockClosure);

smalltalk.addMethod(
smalltalk.method({
selector: "appendToJQuery:",
category: '*Canvas',
fn: function (aJQuery){
var self=this;
function $HTMLCanvas(){return smalltalk.HTMLCanvas||(typeof HTMLCanvas=="undefined"?nil:HTMLCanvas)}
return smalltalk.withContext(function($ctx1) { 
_st(self)._value_(_st($HTMLCanvas())._onJQuery_(aJQuery));
return self}, function($ctx1) {$ctx1.fill(self,"appendToJQuery:",{aJQuery:aJQuery},smalltalk.BlockClosure)})},
args: ["aJQuery"],
source: "appendToJQuery: aJQuery\x0a\x09self value: (HTMLCanvas onJQuery: aJQuery)",
messageSends: ["value:", "onJQuery:"],
referencedClasses: ["HTMLCanvas"]
}),
smalltalk.BlockClosure);

smalltalk.addMethod(
smalltalk.method({
selector: "asSnippet",
category: '*Canvas',
fn: function (){
var self=this;
function $HTMLSnippet(){return smalltalk.HTMLSnippet||(typeof HTMLSnippet=="undefined"?nil:HTMLSnippet)}
return smalltalk.withContext(function($ctx1) { 
var $1;
$1=_st(_st($HTMLSnippet())._current())._snippetAt_(_st(self)._asString());
return $1;
}, function($ctx1) {$ctx1.fill(self,"asSnippet",{},smalltalk.CharacterArray)})},
args: [],
source: "asSnippet\x0a\x09^ HTMLSnippet current snippetAt: self asString",
messageSends: ["snippetAt:", "asString", "current"],
referencedClasses: ["HTMLSnippet"]
}),
smalltalk.CharacterArray);

smalltalk.addMethod(
smalltalk.method({
selector: "appendToBrush:",
category: '*Canvas',
fn: function (aTagBrush){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(aTagBrush)._appendString_(self);
return self}, function($ctx1) {$ctx1.fill(self,"appendToBrush:",{aTagBrush:aTagBrush},smalltalk.String)})},
args: ["aTagBrush"],
source: "appendToBrush: aTagBrush\x0a\x09aTagBrush appendString: self",
messageSends: ["appendString:"],
referencedClasses: []
}),
smalltalk.String);

smalltalk.addMethod(
smalltalk.method({
selector: "appendToJQuery:",
category: '*Canvas',
fn: function (aJQuery){
var self=this;
return smalltalk.withContext(function($ctx1) { 
_st(aJQuery)._append_(self);
return self}, function($ctx1) {$ctx1.fill(self,"appendToJQuery:",{aJQuery:aJQuery},smalltalk.String)})},
args: ["aJQuery"],
source: "appendToJQuery: aJQuery\x0a\x09aJQuery append: self",
messageSends: ["append:"],
referencedClasses: []
}),
smalltalk.String);

smalltalk.addMethod(
smalltalk.method({
selector: "asJQuery",
category: '*Canvas',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
return jQuery(String(self));
return self}, function($ctx1) {$ctx1.fill(self,"asJQuery",{},smalltalk.String)})},
args: [],
source: "asJQuery\x0a\x09<return jQuery(String(self))>",
messageSends: [],
referencedClasses: []
}),
smalltalk.String);

smalltalk.addMethod(
smalltalk.method({
selector: "asJQuery",
category: '*Canvas',
fn: function (){
var self=this;
return smalltalk.withContext(function($ctx1) { 
return jQuery(self['@jsObject']);
return self}, function($ctx1) {$ctx1.fill(self,"asJQuery",{},smalltalk.JSObjectProxy)})},
args: [],
source: "asJQuery\x0a\x09<return jQuery(self['@jsObject'])>",
messageSends: [],
referencedClasses: []
}),
smalltalk.JSObjectProxy);

